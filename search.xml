<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MongoDB的安装、配置、采坑和使用]]></title>
    <url>%2F2017%2F12%2F26%2FMongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E3%80%81%E9%87%87%E5%9D%91%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[版本提示这里我用的是3.2.4版本 安装和配置1234567linxu命令cd d:cmd命令d:然后执行mkdir mongomkdir MongoDB 将软件安装到mongo目录里，安装时选择custom模式。安装完成后。123456cd MondoDBmkdir datamkdir logsmkdir etccd etc/vi mongo.conf 按下 i 进入编辑模式，输入 12345678dbpath=D:\MongoDB\data\dblogpath=D:\MongoDB\logs\mongo.loglogappend=truequiet=trueport=27017journal=truehttpinterface=truestorageEngine=mmapv1 然后按下ESC键，输入:wq 按下回车保存并退出。 继续输入以下命令123456cd ..cd data/mkdir dbcd ..cd logs/touch mongo.log 以上关于关键的安装和与数据库的链接都配置好了，下面进行环境变量配置 右击我的电脑，选择属性，点击高级系统设置，找到环境变量设置，点击进去，选择系统变量，找到PATH，将类似这种D:\mongo\bin路径添加进去，注意与前一个环境变量路径用分号隔开。然后重启dos，输入 1mongo --version 就可以查看mongo的版本了。 使用dos窗口下输入： 1mongod --config D:\MongoDB\etc\mongo.conf 就可以启动mongo了，输入命令后。打开浏览器localhost:27017,可以看到一段文字 It looks like you are trying to access MongoDB over HTTP on the native driver port.说明启动mongo成功，接着打开localhost:28017,会看到数据库的详细内容。 mongovue的使用 下载 mongvue 后，启动，然后点击最前面的窗口上的加号，然后设置设置name，server，port就可以了，下面的用户密码什么的不要设置，然点击save。就可以新建一个数据库服务器了。可以同时在命令行中使用这个数据库，来进行创建。 配置成服务在mongo.conf文件里添加一行serviceName = “MongoDB”然后输入以下命令123mongod --install -f D:\MongoDB\etc\mongo.conf回车后执行：net start MongoDB 就可以创建成功MongoDB服务了，这样做的目的是省去了每次都要用 1mongod --config D:\MongoDB\etc\mongo.conf 来启动服务器，这样就可以直接使用mongo命令了。 1// net stop MongoDB 来停止MongoDB服务 增删改查 这个看api吧，很简单。 导入数据文件的两种方式 使用mongvue导入，右击collection的，点击import选项，点击multi选项，选择导入的文件。 使用命令行 123// db_demo --&gt; 数据库名字// collection_name --&gt; collection名字，相当于mysql里的table名字mongoimport -d db_demo -c collection_name --file XXXXX 采坑记录设置环境变量后，重启dos输入命令，提示不是内部命令。 分号什么的都加了，没有问题，但是就是运行不了命令，甚至重启也试了，最后解决的方法是：我把路径放在了PATH变量的最前面，也就是第一个值。就可以了，吐血。。。 配置服务后，配置和命令什么的都对，执行完命令，换行结束，但是打开服务，刷新，没有发现MongDB服务。 最后查看了日志，发现拒绝访问，cmd没有管理员权限。然后用了管理员的方式打开了dos，重新执行了配置服务，成功解决了。]]></content>
      <categories>
        <category>MongDB</category>
      </categories>
      <tags>
        <tag>MongDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD、CMD、CommonJS、ES6比较]]></title>
    <url>%2F2017%2F12%2F20%2FAMD%E3%80%81CMD%E3%80%81CommonJS%E3%80%81ES6%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[共同点都是前端模块化过程中的标准和规范。 不同点AMD 是RequireJS产品的标准，异步加载，依赖前置，也就是我先把需要依赖的都先加载好，后面需要用的时候，才使用。 CMD 是淘宝SeaJS的标准，依赖就近，同步加载，同步就是即用即返回的意识。也就是我需要用到这个模块的时候，才去加载，然后调用。 CommonJS 是服务端进行模块划分的标准，也就是node.js的标准，前端不支持，也就是浏览器不支持。 ES6 是前端模块化划分标准，主流浏览器基本都支持。 总结每一种标准都是在为前端模块化做贡献，为前端发展做贡献。]]></content>
      <categories>
        <category>Experiences</category>
      </categories>
      <tags>
        <tag>Experiences</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象、数组、字符串之间的各种形式转换]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%95%B0%E7%BB%84%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%84%E7%A7%8D%E5%BD%A2%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[项目开发中总结的各种转换函数的写法 需要用到的工具函数1234567function splitEnv(str, separator = '=') &#123; const index = str.indexOf(separator); return [ str.slice(0, index), str.slice(index + 1), ];&#125;; [“name=yk”, “age=12”] ==&gt; [[“name”, “yk”], [“age”, “12”]]123// 将形如键值对的字符串分隔成含有键和值字符串的数组 const arr = ["name=yk", "age=12"];arr.map(str =&gt; splitEnv(str)); [[“name”, “yk”], [“age”, “12”]] ==&gt; [[“name”, “yk”]]12// 过滤出键不为‘age’的数组arr.filter(env =&gt; env[0] !== 'age'); [[“name”, “yk”]], ==&gt; [“name=yk”]12// 将数组中含有数组其中是键和值字符串，转换成键值形式字符串数组arr.map(item =&gt; item.join('=')); [“aa”, “bb”] ==&gt; [“aa”, “bb”, “cc”]在字符串数组里添加一个指定的字符串12345678910const arr = ["aa", "bb"];const str = "cc";// 第一种使用es6[...arr, str];//第二种使用concatarr.concat([str]);一般是用函数获得这个字符串，要考虑如果没有呢用 return str ? [str] : [] 将数字数组变成对象数组12345678910111213this.instance = &#123; ports: [80] &#125;;ports() &#123; const &#123; ports &#125; = this.instance; return ports.map(port =&gt; (&#123; port, protcol: 'http' &#125;));&#125;上面的结果就是ports = [&#123; port: 80, protcol: 'http'&#125;];也就是进入ports = [80]数组中，对元素80进行转换，然后将其在数组中的位置替代，这里将数字转换成了对象，然后将数字替换成了对象。port =&gt; (&#123; port, protcol: 'http' &#125;)这句是let port = ports[index];port: 80解构赋值了 字符串数组转换成对象数组1234567891011121314151617181920212223242526header: [ '变量 ID', '变量名', '类型', '变量描述', '是否必填', '默认值', &#123;text: '编辑'&#125;, ],header.map(h =&gt; (&#123; text: h.text ? h.text : h, tooltip: h.tooltip, &#125;));header: [ '变量 ID', '变量名', '类型', '变量描述', '是否必填', '默认值', &#123;text: '编辑'&#125;, ],输出如下： 对象组成的数组 转换成 数组组成的数组12345const objectArr = [&#123;age:12&#125;, &#123;sex:"man", &#123;hobby:"tea"&#125;];通过objectArr.map(item =&gt; Object.entries(item));可以转换成[ ["age", 12], ["sex", "man"], ["hobby", "tea"] ] 将对象组成的数组中的所有对象的键或者值保存在一个数组中12345const objectArr = [&#123;age:12&#125;, &#123;sex:"man", &#123;hobby:"tea"&#125;];通过objectArr.map(item =&gt; Object.keys(item).toString());可以转换成["age", "sex", "hobby"] 上面的做法不够鲁棒，有bug 下面的这写法很全面，很鲁棒，不改变值的数据类型，键默认都是字符串形式1234567891011var objectArr = [&#123;age:12, y:11&#125;, &#123;sex:"man"&#125;, &#123;hobby:"tea"&#125;];objectArr.((arr, cur) =&gt; &#123;return arr.concat(Object.keys(cur));&#125;, []);(输出) ["age", "y", "sex", "hobby"]var objectArr = [&#123;age:12, y:11&#125;, &#123;sex:"man"&#125;, &#123;hobby:"tea"&#125;];objectArr.reduce((arr, cur) =&gt; &#123;return arr.concat(Object.values(cur));&#125;, []);(输出) [12, 11, "man", "tea"]]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组方法返回值的总结]]></title>
    <url>%2F2017%2F11%2F20%2FJS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[不会改变原数组的方法 slice concat 返回新的数组 map filter forEach 改变原数组的方法 pop 返回被删除的元素的值 push 返回数组新的长度 shift unshift splice 返回新数组 sort 其他数组方法 join() 返回字符串 split() 将字符串解析成数组，返回数组，并且数组中的每个元素都是字符串 sort() 返回排序后的数组 filter() 返回的数组元素是调用的数组的一个子集，并且是新数组 map() 返回的是新数组 indexOf() 返回找到的第一个元素的索引值，没有则返回-1 isArray() 返回true或者false 用来检测是否为数组的最好的方法，比instanceof靠谱 reduce() 返回单个值 forEach() 返回一个数组的拷贝，不会修改原数组 find() 返回第一个找到的元素，没有找到就返回undefined]]></content>
      <categories>
        <category>Experiences</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历在开发中的使用]]></title>
    <url>%2F2017%2F11%2F01%2Freduce%E7%94%A8%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20(3)%2F</url>
    <content type="text"><![CDATA[下面这种遍历在开发中很常见，在这里总结一下。123456789101112let s1 = 1;let s2 = 2;const obj = &#123; s1, s2 &#125;;上面显示为 obj = &#123; s1: 1, s2: 2 &#125;一般是用Object.keys(obj)方法获得obj对象的所有的键属性值let arr = ["s1", "s2"]然后对键属性值，也就是字符串数组进行forEach，然后挨个进行添加或者其他操作arr.forEach(key =&gt; &#123; XXXXX = obj[key]&#125;)获取对象的键对应的值，有两种方法，第一种直接obj.s1 第二种是obj['s1']，一般用第二种，先将s1变成字符串形式]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类数组对象]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[而对于一个普通的对象来说，如果它的所有property名均为正整数，同时也有相应的length属性，那么虽然该对象并不是由Array构造函数所创建的，它依然呈现出数组的行为，在这种情况下，这些对象被称为“类数组对象”。 1234var o =&#123;0:7,1:8,2:9,length:3&#125;console.log(0);可以用Array.from(o)来使其变成数组[7,8,9] 与普通对象不同的是，类数组对象拥有一个特性：可以在类数组对象上应用数组的操作方法。比如，在ECMAScript 5标准中，可以用以下方法来将上面的对象o合并成字符串： 12console.log(Array.prototype.join.call(o));//输出：“7,8,9” 在浏览器环境中，document.getElementsByTagName()语句返回的就是一个类数组对象。在function调用中，function代码内的arguments变量(保存传入的参数)也是一个类数组对象。 在ECMAScript 5标准中，字符串string就是一个只读的类数组对象： 123451 var s = "godkun";2 console.log(s[3]);//输出：d3 console.log(Array.prototype.join.call(s, " "));//输出：g o d k u n]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历在开发中的使用]]></title>
    <url>%2F2017%2F10%2F28%2F%E9%81%8D%E5%8E%86%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[下面这种遍历在开发中很常见，在这里总结一下。123456789101112let s1 = 1;let s2 = 2;const obj = &#123; s1, s2 &#125;;上面显示为 obj = &#123; s1: 1, s2: 2 &#125;一般是用Object.keys(obj)方法获得obj对象的所有的键属性值let arr = ["s1", "s2"]然后对键属性值，也就是字符串数组进行forEach，然后挨个进行添加或者其他操作arr.forEach(key =&gt; &#123; XXXXX = obj[key]&#125;)获取对象的键对应的值，有两种方法，第一种直接obj.s1 第二种是obj['s1']，一般用第二种，先将s1变成字符串形式]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reduce用法]]></title>
    <url>%2F2017%2F10%2F28%2Freduce%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[灵活的运用reduce来进行各种各样的类型转换，比如将数组按照一定规则转换为对象，也可以将一种形式的数组转换为另一种形式的数组 结合map，可以任意转成键值对对象 1234reduce((map, field) =&gt; &#123; map.set(); return map; &#125;, new Map()) 1234[1, 2].reduce(function(res, cur) &#123; res.push(cur + 1); return res; &#125;, []) 后面定义的[]是res, 然后cur是第一个数据，很万能的方法。]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON心得]]></title>
    <url>%2F2017%2F10%2F27%2FJSON%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[JSON的总结1: 是一种数据交换格式，其实就是一个文本文件2: 独立于编程语言3：基于JS对象字面量表示法4：表达数据的方式对通用的编程概念都很友好注意：数据交换格式是一种在不同平台或者系统间传递数据的文本格式。而表示法是指一个用于诸如数字或单词等数据的字符系统。 一些值得思考的地方字面量是什么意识在编程语言中的literal(字面量)是一个名词，所谓字面量，就是对数据值的具体表示。比如 x = 5; 这里的 x 是变量x = x + 5; 这里我们肯定知道 x = 10了，其中的 5 就是字面量，也就是我们看到的实际值，就是字面的值。比如5美元就是字面量，而行用卡就是变量 书写正确的格式JSON中的名称一定要用双引号包裹，值不一定用，值可以是字符串、数字、布尔值、null、对象或者数组。JSON中，多个名称-值对使用逗号分割JSON媒体类型是application/json 验证json是否正确使用JSONLint 从机器的角度去理解JSON{ 指开始读取对象} 指结束读取对象[ 指开始读取数组] 指结束读取数组: 指在名称-值对中分割名称和值，逗号指分割对象中的名称-值对，或者分割数组中的值，也可以认为是一个新部分的开始 所以如果书写不正确，就无法解析，比如你在名称-值对列表的结尾处加上一个逗号，就会报错，因为你给机器的指令是”一个新部分的开始“，但是后面什么都没有，所以当然报错了 小知识1: JSON不是JavaScript对象字面量，它只是基于JavaScript对象字面量，所以在JSON中，仅允许使用双引号来包裹字符串。2：当值中含有双引号和反斜线等字符时，要用反斜线进行转义，不然会报错。3：对象和数组很关键的一个区别就是，对象是名称-值对构成的列表或集合，数组是值构成的列表或集合。4：数组中所有的值应具有相同的数据类型。5：JSON中的null值的所有字母必须小写6：JSON不能解析嵌套的对象 JSON Schema是对JSON数据格式的一致性进行验证，是数据发送方节约时间，保证数据正确的好工具链接地址：http://json-schema.org/examples.html可以解决以下问题1: 值的数据类型是否正确？ 可以具体规定一个值是数字、字符串等类型2：是否包含所需要的数据？ 可以规定哪些数据是需要的，哪些是不需要的3：值的形式是不是我需要的？ 可以指定范围，最小值和最大值 JSON安全问题1：不要使用顶层数组，顶层数组是合法的JavaScript脚本，它们可以用 script标签链接并使用2：对于不想公开的资源，仅允许使用HTTP POST方法请求，而不是GET方法，GET方法可以通过URL来请求，甚至可以放在script标签中3：使用JSON.parse()来代替eval()， eval()函数会将传入的字符串编译并执行，这会让你的代码易被攻击。仅仅使用JSON.parse()来解析JSON数据4：要对值内的div这种代码进行转码，比如转成&lt;div&gt; 不转码的话会有安全风险 术语解释1：顶层JSON数组存在于JSON名称-值对之外的位于文档最顶层的JSON数组也就是这种类型的：[ { “user”: “yk” }, { “age”: 22 }]属于合法的危险的JSON2：服务端当页面或资源被请求时，在服务器上执行的一系列操作。服务器为互联网浏览器提供其处理和加载的响应 前后端进行配合1：序列化：将对象转化为文本的操作2：反序列化；将文本转化为对象的操作3：客户端的XMLHTTPRequest需要服务端的支持来保证JSON资源请求成功 CORS [跨域资源共享，可以解决同源策略的影响说]服务器会在响应头额外加上一些带有Access-Control-Allow前缀的属性比如：Access-Control-Allow-Methods: POSTAccess-Control-Allow-Origin: http://www.example.com这表示我们仅允许通过POST来请求资源，如果有人想用script标签来进行请求，浏览器就会阻止他。并且浏览器会禁止除http://www.example.com以外的站点去获取资源。 JSON-PP是padding的意识，也就是内联，JSON-P就是指带有padding的JSON，内联是什么意识，就是将JS加入JSON文档例如：getTheAnimal( { “animal”: “cat” });函数参数是JSON，函数参数提供了一种将数据传递给函数的方式。如果需要一个函数来实现两数相加的功能，首先就需要一个能够将两个数传递给函数的方式。该函数是在客户端的JS代码中定义的服务器端也要对JSON-P提供一定的支持，它应允许用户自定义函数的名字。它通常是作为URL中的queryString的参数来传递的比如通过queryString告知服务器函数的名字script.src = “http://example.com/animal.json?callback=getThing“服务端根据callback参数的值动态的为在JSON中内联的函数命名]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用二分法打印第一个目标元素出现的下标和最后一个元素出现的下标]]></title>
    <url>%2F2017%2F07%2F25%2F%E7%94%A8%E4%BA%8C%E5%88%86%E6%B3%95%E6%89%93%E5%8D%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%AE%E6%A0%87%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%8B%E6%A0%87%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%8B%E6%A0%87%2F</url>
    <content type="text"><![CDATA[比较简单，直接上代码了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class BinaryFind &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,4,5,6,7,11,22,33,234&#125;; int a = f1(arr, 4); System.out.println("4第一次出现的下标为：" + a); int b = f2(arr, 4); System.out.println("4最后一次出现的下标为: " + b); &#125; // 用二分法打印打一次出现的目标元素的下标 public static int f1(int[] arr, int value)&#123; int left = 0; int right = arr.length - 1; int mid; while (left &lt; right)&#123; // 这里是关键代码，向右进位需要多加1 mid = (left + right) / 2; if (arr[mid] &lt; value)&#123; left = mid + 1; &#125;else &#123; right = mid; &#125; &#125; if (arr[left] == value) return left; else return -1; &#125; // 用二分法打印打最后出现的目标元素的下标 public static int f2(int[] arr, int value)&#123; int left = 0; int right = arr.length - 1; int mid; while (left &lt; right)&#123; mid = (left + right + 1) / 2; if (arr[mid] &gt; value)&#123; right = mid - 1; &#125;else &#123; left = mid; &#125; &#125; if (arr[left] == value) return left; else return -1; &#125;&#125; 总结 在最简单的二分法的实现上进行了优化，使其可以选择输出目标元素的位置。这里需要注意代码中，字为关键代码的注释的那句代码，如果不加1，则会死循环。时间复杂度为O(lgN)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印两个有序链表的公共部分]]></title>
    <url>%2F2017%2F07%2F24%2F%E6%89%93%E5%8D%B0%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[直接上代码了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ReverseSingleLink &#123; public static void main(String[] args) &#123; Node head1 = new Node(1); Node head2 = new Node(3); Node node1 = new Node(2); Node node2 = new Node(3); Node node3 = new Node(4); Node node4 = new Node(5); head1.next = node1; node1.next = node2; node2.next = node3; head2.next = node4; printCommonPart(head1,head2); System.out.print("head1链表为："); // 打印出链表head1 while (head1 != null)&#123; System.out.print(head1.value+" "); head1 = head1.next; &#125; System.out.println(); System.out.print("head2链表为："); // 打印出链表head2 while (head2 != null)&#123; System.out.print(head2.value+" "); head2 = head2.next; &#125; System.out.println(); &#125; public static void printCommonPart(Node head1, Node head2) &#123; System.out.print("公共部分是："); // 关键代码 while (head1 != null &amp;&amp; head2 != null) &#123; if (head1.value &lt; head2.value) &#123; head1 = head1.next; &#125; else if (head1.value &gt; head2.value) &#123; head2 = head2.next; &#125; else &#123; System.out.print(head1.value + " "); head1 = head1.next; head2 = head2.next; &#125; &#125; System.out.println(); &#125;&#125; 输出截图 思路 如果head1的值小于head2，head1往后移动一位 如果head1的值大于head2，head2往后移动一位 如果head1的值等于head2，则打印出这个值，并同时使head1和head2往后移动一位 直到head1或者head2其中任何一个移动到了null，整个过程就停止 总结很简单，时间复杂度为O(N)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断一个数是否是回文数]]></title>
    <url>%2F2017%2F07%2F24%2F%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E6%98%AF%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[回文数的定义 对于非负数 其左右两边完全相同 则是回文。 例如: 121、22。对于负数 其绝对值左右两边完全相同 则是回文。 例如: -121、-22。设计一个算法判断给定的数是否为回文数，如果是，输出true 反之 输出false。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Palindrome &#123; // 主函数，用于测试，在控制台输入一个数。 public static void main(String[] args) &#123; Palindrome test = new Palindrome(); Scanner in = new Scanner(System.in); int s = in.nextInt(); System.out.println("输入的数是："+ s); System.out.println("是否是回文数："+ test.isPalindrome(s)); &#125; // 判断回文数方法 public boolean isPalindrome(int n)&#123; // 如果已经 if (n == Integer.MIN_VALUE)&#123; return false; &#125; // 取绝对值 n = Math.abs(n); int help = 1; // 将help位数变为与n一致 while ( n / help &gt;= 10)&#123; help *= 10; &#125; // n = 0 表示所有位比较完 while (n != 0)&#123; // 最高位 != 最低位 if (n / help != n % 10)&#123; return false; &#125; // 去掉最高位和最低位，因为已经比较过了 n = (n % help) / 10; // 由于去掉两位，所以help要除以100 help /= 100; &#125; return true; &#125;&#125; 输出截图 总结非常好的思路，时间复杂度为O(N)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的划分]]></title>
    <url>%2F2017%2F07%2F24%2F%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[问题 给定一个数组arr，其中只含有0,1,2三种元素，请对arr进行排序 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Partition &#123; public static void main(String[] args) &#123; int[] arr = &#123;0,0,1,2,1,2,1,0,2,1&#125;; // 调用排序函数 sortPart(arr); // 循环输出数组 for (int j = 0; j &lt; arr.length; j++)&#123; System.out.print(arr[j] + " "); &#125; &#125; public static void sortPart(int[] arr)&#123; // 判断数组是否为空 if (arr == null || arr.length == 0)&#123; return; &#125; // 定义存放0的区域为left，存放1的区域为index，存放2的区域为right int left = -1; int right = arr.length; int index = 0; // 关键代码，通过if判断加上互相交换函数，进行数值划分 while(index &lt; right)&#123; if (arr[index] == 0)&#123; swap(arr, ++left, index++); &#125; else if (arr[index] == 2)&#123; swap(arr, index, --right); &#125;else &#123; index++; &#125; &#125; &#125; // 对数组中的两个值进行交换 public static void swap(int[] arr, int i, int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 输出如下图 复杂度时间复杂度为O(N),是最优解。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用一个栈实现另一个栈的排序]]></title>
    <url>%2F2017%2F07%2F23%2F%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目： 一个栈元素的类型为整数，现在要想将该栈从顶到底按从大到小的顺序排列。要求：只允许申请一个栈，除此之外，可以申请一个变量，可以申请额外的变量，但是不能申请额外的数据结构，如何完成排序 代码如下123456789101112131415161718192021222324252627282930313233343536373839public class NO2 &#123; public static void main(String[] args) &#123; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); s.push(2); s.push(4); s.push(3); s.push(5); s.push(22); s.push(7); s.push(1); s = sortByStack(s); while (!s.isEmpty())&#123; System.out.println(s.pop()); &#125; &#125; public static Stack&lt;Integer&gt; sortByStack(Stack&lt;Integer&gt; stack1)&#123; Stack&lt;Integer&gt; help = new Stack&lt;Integer&gt;(); while (!stack1.isEmpty())&#123; // 需要用到pop的值时，应该先用一个变量将其保存下来。 int cur = stack1.pop(); while (!help.isEmpty() &amp;&amp; cur &gt; help.peek())&#123; // 这里要注意哦，help栈弹出数据以后，先push到stack1中，否则弹出的数据无法得到利用。 stack1.push(help.pop()); &#125; help.push(cur); &#125; // 依次将help栈中的数据放入stack1栈中 while (!help.isEmpty())&#123; stack1.push(help.pop()); &#125; // 返回已经排好序的stack1 return stack1; &#125;&#125; 思路这种题直接用内置栈实例化一个栈对象即可，再在方法里实例化一个空的新栈用来保存前一个栈弹出的数据，并且进行比较排序，最后将新栈的数据依次放入目标栈中。 复杂度 时间复杂度：属于O(N)的算法]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵的最短路径和]]></title>
    <url>%2F2017%2F07%2F22%2F%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[问题描述 给定一个矩阵m，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有路径中最小的路径和。 解决的代码如下：12345678910111213141516171819202122232425262728293031323334353637package recursiveAndDp;/** * Created by godkun on 2017/7/22. */public class MinPathSum &#123; public static void main(String[] args) &#123; int[][] a = &#123;&#123;1,4,9,18&#125;,&#123;9,5,8,12&#125;,&#123;15,5,11,12&#125;,&#123;22,13,15,12&#125;&#125;; System.out.println(f1(a)); &#125; public static int f1(int[][] m) &#123; if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) &#123; return 0; &#125; int row = m.length; int col = m[0].length; int[][] dp = new int[row][col]; dp[0][0] = m[0][0]; // 第一行只能从左到右 for (int i = 1; i &lt; row; i++)&#123; dp[i][0] = dp[i-1][0] + m[i][0]; &#125; // 第一列只能从上到下 for (int j = 1; j &lt; col; j++)&#123; dp[0][j] = dp[0][j - 1] + m[0][j]; &#125; for (int i = 1; i &lt; row; i++)&#123; for (int j = 1; j &lt; col; j++)&#123; dp[i][j] = Math.min(dp[i - 1][j],dp[i][j - 1]) + m[i][j]; &#125; &#125; // 返回最小路径和，也就是二维数组表里的最后一个值 return dp[row - 1][col - 1]; &#125;&#125; 思路 使用动态规划做，先定义一个一样大小的二维数组dp[][], 先对dp[0][j]这一行进行确定最短路径，然后对dp[i][0]这一列进行确定最短路径，最后通过dp[i][j] = Math.min(dp[i - 1][j],dp[i][j - 1]) + m[i][j];也就是通过前面已经求出的一行和一列推出最短路的和。 复杂度时间复杂度是O(M x N)，由于dp[i][j]，所以空间复杂度也是O(M X N)。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于动态规划]]></title>
    <url>%2F2017%2F07%2F15%2F%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[概念 先把问题分割成若干个子问题，然后求出子问题的答案，最后再利用这些答案得出整个问题的最终答案。 注意：动态规划的核心就是将子问题的答案预先保存到内存中。这个保存答案的内存区域就是缓存。然后重复利用其结果就能显著提高运算速度。 动态规划就是通过预存（重复计算两次以上的）子问题结果值来提高运算速度的算法设计。 对比递归可以看出，递归没有对子问题运算的结果进行保存，这会出现很多重复计算。 如何运用动态规划 这里我们要时刻想到把计算结果缓存下来，对于用什么缓存数据结构，因题目而异，多数情况下用数组就看满足缓存要求。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法和递归法的区别]]></title>
    <url>%2F2017%2F07%2F14%2F%E5%88%86%E6%B2%BB%E6%B3%95%E5%92%8C%E9%80%92%E5%BD%92%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[递归调用总是把问题分解为一个小问题和剩下的所有问题。分治法会把问题分解为同等大小的子问题。 下面一张图就可以很明显的看出两者的区别 上图左边是递归调用算法，右边是分治算法。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结的一些JavaScript小技巧]]></title>
    <url>%2F2017%2F07%2F14%2F%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%9A%84%E4%B8%80%E4%BA%9BJavaScript%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[使用 + 将字符串转换成数字测试代码如图： 提示一下，只适合字符串数据是全数字的，如果是”abc”或者”1ab”，则输出NaN，还有一个非常好的技巧，如果是”012”或者”0023”，则输出12，自动把字符串的最前面的所有0去掉。 还有一个好处，如下图，在new Date()前面加上 + 将返回一个时间戳。 在循环中缓存array.length 看下面这个数组循环 123for(var i = 0; i &lt; array.length; i++)&#123; console.log(array[i]);&#125; 如果是小数组，上面这样很好，如果是处理一个很大的数组，这段代码在每次迭代时，都会重新计算数组的大小，就会影响性能，为了避免这种现象，可以将array.length做一个缓存，如下面代码所示：1234var length = array.length;for(var i = 0; i &lt; length; i++)&#123; console.log(array[i]);&#125; 合并数组 合并两个数组，一般情况之下你都会使用Array.concat()函数，然而这个函数并不适合用来合并两个大型的数组，因为会消耗大量的内存来存储新创建的数组。可以使用Array.pus().apply(arr1,arr2)来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用。代码如图所示：123var array1 = [1,2,3]; var array2 = [4,5,6]; console.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6];]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续子数组的最大和]]></title>
    <url>%2F2017%2F07%2F13%2F%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[问题描述： 输入一个整型数组，数组里有正数，也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。 解决代码如下 1234567891011121314151617181920212223242526272829public class Test3 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, -6, 7, 1, -1&#125;; System.out.println(maxSub(arr)); &#125; // 用到了动态规划的思想 private static int maxSub(int[] arr)&#123; if(arr == null || arr.length == 0)&#123; return 0; &#125; int max = 0; int n = arr.length; int sum = 0; for(int i = 0; i&lt;n; i++)&#123; sum += arr[i]; if (sum &gt; max)&#123; max = sum; &#125; else if(sum &lt; 0)&#123; sum = 0; &#125; &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于二进制的编程]]></title>
    <url>%2F2017%2F07%2F13%2F%E5%85%B3%E4%BA%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[问题描述： 请实现一个函数，输入一个整数，输出该二进制表示中 1 的个数。例如把 10 表示成二进制是 1010， 有 2 位是 1。 解决代码如下 1234567891011121314151617181920212223public class Test2 &#123; public static void main(String[] args) &#123; // 从控制台中输入一个整数 Scanner in = new Scanner(System.in); int c = in.nextInt(); System.out.println(getNum(c)); &#125; // 主类中的静态方法 private static int getNum(int n)&#123; // 设定 1 的个数初始化值为0 int num = 0; while (n != 0)&#123; num++; // 将整数减 1，再和原整数做与运算，会使该整数最右边的一个 1 变成 0 n = (n-1) &amp; n; &#125; return num; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组的游戏]]></title>
    <url>%2F2017%2F07%2F12%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[问题描述： 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否函数该整数。 解决代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** *编程思路：先选择右上角作为比较元素。 *如果比寻找的元素大，则删除比较元素所在的列，同时比较元素继续是右上角的数字。 *如果比寻找的元素小，则删除比较元素所在的行，同时比较元素继续是右上角的数字。 */public class Test1 &#123; public static void main(String[] args)&#123; int [][] arr = &#123; &#123;1, 2, 8, 9&#125;, &#123;2, 4, 9, 12&#125;, &#123;4, 7, 10, 13&#125;, &#123;6, 8, 11, 15&#125; &#125;; // 用while循环来实现多次输入待寻找数据 while(true)&#123; // 使用Scanner类实现控制台输入 Scanner in = new Scanner(System.in); int c = in.nextInt(); // 静态方法在主函数中可以用写类前缀，直接调用 System.out.println(search(arr, c)); &#125; &#125; // 使用私有静态方法 private static boolean search(int[][] arr, int value)&#123; // 二维数组的列数 int a = arr[0].length; // 二维数组的行数 int b = arr.length; int i = 0; int j = a-1; while (i&lt;=b-1 &amp;&amp; j&gt;=0)&#123; if (arr[i][j]==value)&#123; return true; &#125; if (arr[i][j] &gt; value)&#123; j--; &#125; else &#123; i++; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之函数调用的汇编语言层次解析]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%B1%82%E6%AC%A1%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[只要有调用，就必须要做以下事件： 保护现场。 将控制权交给被调用函数，同时为被调用函数分配局部变量空间。 从被调用回到调用。 将控制转移权交回调用函数。 注意：从被调用回到调用时，会把局部变量所占空间释放掉，并将返回值带回去。注意：怎么将控制转移权交回调用函数？ 通过当时保存的地址。]]></content>
      <categories>
        <category>Computer-Composition</category>
      </categories>
      <tags>
        <tag>Computer-Composition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习第一篇]]></title>
    <url>%2F2017%2F07%2F12%2FVUE%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[移动端常用开发技巧 flex弹性布局 CSS stickfooter 酷炫的交互设计 VUE.js简洁 一个构建数据驱动的web界面的库 只聚焦于视图层 目标：通过尽可能简单的API实现响应的数据绑定和组合的视图组件 一个MVVM框架图 安装Vue-cli 首先要先安装 node 然后 1npm install vue-cli -g 如果出现找不到命令（vue），则是因为npm的路径不再PATH中，将其添加到PATH中即可。 之后执行1vue list 命令查看vue安装成功后的情况 进入项目文件，执行1234567ll -anpm installll -acd node_modulescd ..lsnpm run dev 即可完成vue-cli的安装和页面测试]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于HTML5的一些隐秘的知识]]></title>
    <url>%2F2017%2F07%2F11%2F%E5%85%B3%E4%BA%8EHTML5%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9A%90%E7%A7%98%E7%9A%84%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[用于显示已知范围的标量测量1&lt;meter&gt; 定义周和年控件1week HTML5内建对象1getContent //用于在画布上绘制 SVG定义的图形是XML格式在HTML5中123contextmenu spellcheck//HTML属性 getCurrentPosition()获得用户的当前位置HTML5中不再支持1&lt;acronym&gt;和&lt;font&gt;以及&lt;script&gt;元素的rel属性]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从前端角度看输入一个url后会发生什么]]></title>
    <url>%2F2017%2F07%2F08%2F%E4%BB%8E%E5%89%8D%E7%AB%AF%E8%A7%92%E5%BA%A6%E7%9C%8B%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[输入url: godkun.me 详细步骤1、拉取浏览器cache，判断是否需要更新，如果不需要更新则从缓存获取内容直接渲染。判断是否更新的主要依据有：Expires时间、cache设置，浏览器的设置。 2、发送页面header请求。 这个过程发生了一下几个事件： 浏览器向OS询问server的ip地址。 OS发送DNS寻址，并且返回ip以及端口。 建立tcp连接。 页面通过tcp连接发送http头请求 。 接收完成了服务器返回的header 接收完header后，浏览器得到了返回的请求类型（200、304……）、服务器资源是否有更新（如果没有更新直接从cache获取缓存渲染）等信息。 3、如果页面需要进行缓存则将页面缓存起来，同时对页面进行解码（包括gzip解压等）。 4、根据返回的数据类型（html类型、图片类型、声音…）进行页面渲染。 总结通过对单个请求的分析，可以从另一个方面知道页面的性能瓶颈在哪里。最耗时间的是下面两个过程： 接收body部分 ,这与应用层响应时间、网速、服务器出口带宽有关。Tcp连接建立（这与dns解析，网速有关）。]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看见程序语言的精髓第二篇]]></title>
    <url>%2F2017%2F07%2F03%2F%E7%9C%8B%E8%A7%81%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B2%BE%E9%AB%93%E7%AC%AC%E4%BA%8C%E7%AF%87%2F</url>
    <content type="text"><![CDATA[程序员的三大美德：懒惰，急躁和傲慢。透过现象看本质，语言的核心都是一样的，知道其本质才能以不变应万变。 为什么要取名字变量和函数为什么要有名字？回答这个问题其实很简单，但是很多人根本没有想过这个问题，连质疑的态度都没有。 回顾一下，没有发明命名名字以前，计算机是通过编号来代表计算机记录数据的存储位置，例如“123号的数值加1”这样的计算机指令。 对于上面的编号来说，很显然使用名字的指定方法要方便很多。 程序可读性提高，就像给孩子起名字一样，起名以后，你只需要名字就可以确定你的孩子，程序也是一样。我喜欢把名字看成二维码，之前的编号相当于钥匙，还要开门，而现在二维码只需要扫一下就好了。 为什么要有作用域？作用域是什么，为什么要有作用域，设置作用域的目的是什么？ 上面说了给函数和变量起名字会非常方便，但是如果名字起冲突了怎么办，总不能所有名字都不是一样的吧，很明显这是不可能的，也不现实。这个时候计算机科学家就想到了设置作用域来解决这个问题。 作用域是什么？简单点说就是指名字的有效范围，将名字的有效范围限定在更小的范围内，出了这个范围，名字则会无效。基于这个思路，提出了作用域的概念。 作用域分类 动态作用域 静态作用域 容器顾名思义，容器就是用来存放东西的，在程序语言中，把存放多个元素的东西称为容器。 容器中的数据容器中的数据实际上是存放在内存中的。容器的类型不同，内存中存储数据的方式也不同。 如何选择容器首先说一下，没有万能的容器。 根据容器的使用目的，使用方式和操作类型的不同，最适宜的容器类型也会相应地变化。核心：在节约内存和节约计算时间之间寻找最佳平衡。 字符和编码的真相字符其实字符只不过是人们预定好的命名为字符的一系列符号的集合而已。这一符号的集合称为字符集或者字符包，字符集因国家和文化而千差万别。 编码将字符集通过数字化的数据表现出来，就必须考虑如何对字符进行编码。注意：编码方式只不过是人们约定的一系列规则，有些可能是随意决定的！编码方式必须为字符编码方和编码解码方共有，和没有掌握这一编码方式的人是无法进行信息交互的。Unicode：包含世界上所有字符的字符集合。而UTF-8是：一种用来编码Unicode这样统一之后的字符集的编码方式。]]></content>
      <categories>
        <category>Computer-Composition</category>
      </categories>
      <tags>
        <tag>Computer-Composition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻松github-pull-request]]></title>
    <url>%2F2017%2F07%2F01%2F%E8%BD%BB%E6%9D%BEgithub-pull-request%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器 PR先将仓库下载到本地开发环境中1git clone git@github.com:godkun/godkun.github.io.git 就是下图这个地址，换成你的地址就可以 然后进入你的仓库目录中1cd godkun.github.io PR的时候要养成建特性分支后再修改代码的习惯查看仓库的分支1git branch -a 会在终端显示当前的分支名然后创建特性分支1git checkout -b 新的分支名&amp;emsp;当前的分支名 再次使用1git branch -a 查看是否转换分支成功 提交代码编辑完仓库中的代码后，输入1git diff 查看修改是否正确进行 然后进行1git add 修改的文件 再1git commit -m "这是第一次pull request" 创建本地新建分支对应的远程分支1git push origin 新建分支 然后查看分支1git branch -a 发送Pull Request登录github并切换到 对应仓库的 新建分支 ，点击 New pull request再然后,点击 Create pull request 总结 你已经成功完成了一次具有历史意义的征服github的关键一步了。继续加油吧少年。如果有不懂的可以问我 个人联系方式 QQ:357821351 邮箱：godkun666@126.com github地址: https://github.com/godkun]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从存储结构来看JS代码执行的本质]]></title>
    <url>%2F2017%2F06%2F30%2F%E4%BB%8E%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%9D%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[存储体的结构组成 用原型制作工具制作的下面这个简单的示意图。 上图的解释上图是一个存储体的结构，其中 CS 这段称为 域 其大小在程序运行前就已经确定。堆 这段需要人工申请，用 new 方式申请，可以将堆看成一棵树。栈 系统自动分配，先进后出。 下面我用一个例子来解释JS代码在内存中是怎么分配的12345678910111213function Person(id, name, age) &#123; this.id = id; this.name = name; this.age = age;&#125;var num = 10;var bol = true;var str = "abc"; var obj = new Object();var arr = ['a','b','c'];var person = new Person(100, "godkun", "21"); 对上面代码进行解释我在纸上画图手写了这个笔记，如下图 图中左边是栈，右边是堆，在JS中，一般基本变量是把变量名和值一起放在栈中，这样可以提高速度，而引用类型则是把变量名放在栈中，把数据放在堆中。通过栈引用访问堆中数据。 注意：这里我要特别说明一点，从图中看到堆的最外面有个“围墙”，所以无法直接操作存储在堆中的数据，必须通过栈的引用来操作堆中的数据，也就是栈引用堆。 总结栈和堆栈优势：存取速度比堆要快 ，速度仅小于CPU中的寄存器。劣势： 数据的大小和生存期必须是确定的，缺乏灵活性。 堆优势： 动态分配内存大小，生存期也不必事先告知编译器，垃圾收集器会自动收集这些不再使用的数据。劣势： 由于运行时动态分配内存，所以速度慢。]]></content>
      <categories>
        <category>Computer-Composition</category>
      </categories>
      <tags>
        <tag>Computer-Composition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看见程序语言的精髓第一篇]]></title>
    <url>%2F2017%2F06%2F29%2F%E7%9C%8B%E8%A7%81%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B2%BE%E9%AB%93%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[程序员的三大美德：懒惰，急躁和傲慢。透过现象看本质，语言的核心都是一样的，知道其本质才能以不变应万变。 黎明的前奏—语法没有那么神秘，语言设计者制定的规则就是语法。比如 1+2*3 表达式，它的结果可以是7，也可以是9，这取决于语言制定者怎么规定的语法，怎么方便，怎么规定。所以对于大家来说，结果是7更好理解，也就更方便。这就是语法。 语法分析器 语法分析器是把源代码作为字符串读入，解析，并建立语法树的过程。 函数的诞生 我个人觉得就是因为需要重复调用，而函数正好满足这一要求，它可以把结果存在返回值，然后在你需要的时候去调用它，有着非常高的可复用性。 错误异常处理代码为什么那样写这里个背景知识：一个大佬在论文中提出了一种更好的异常处理的方法，大致内容如下一是明确声明命令可能抛出何种异常，二是需要有将可能出错的操作括起来的语句结构。 这个论文直接导致了现在大部分的语言都采用了先括起来可能出错的操作，再编写错误处理的语句结构。 现在最经典的异常处理结构语言如下：1234567try&#123; /* 可能出错的代码 */&#125; catch(...) &#123; /* 异常处理代码 */&#125; finally &#123; /* 必将执行的代码 */&#125; 这里说一下为什么要加一个finally语句，因为如果不加一个必将执行的代码的话，那么这个被调用的函数如果在多处都有抛出异常的可能性，就会导致在很多地方都有可能跳出这个函数，此时就会出现函数调用过程不完整。]]></content>
      <categories>
        <category>Computer-Composition</category>
      </categories>
      <tags>
        <tag>Computer-Composition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之散列]]></title>
    <url>%2F2017%2F06%2F26%2FJS%E4%B9%8B%E6%95%A3%E5%88%97%2F</url>
    <content type="text"><![CDATA[概念 散列是一种数据存储技术，散列后的数据可以快速地插入或取用。散列使用的数据结构叫做散列表，散列表是基于数组进行设计的。而且数组的长度是预先设定的，可以随时更改。 原则 确保散列表中用来存储数据的数组大小是质数。这是为了防止碰撞。 散列原理 使用散列表存储数据时，通过一个散列函数将键映射为一个数字，这个数字的范围是0到散列表的长度。 散列函数基本性质 如果两个散列值是不相同多的，那么这两个散列值的原始输入也是不相同的。 散列函数的选择 散列函数的选择依赖于键值的数据类型，如果键是整型，最简单的散列函数就是【 键值 % 数组的长度 】，这就是为什么数组的长度必须取质数的原因了，不然会很容易发生碰撞。如果键是字符串类型，需要选取合适的散列函数。 好的散列函数之 霍纳算法 先计算各字符的ASCII码值，在求和时要乘以一个质数。 下面是一个利用霍纳算法的最基本的散列程序，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 使用一个类来表示散列表function HashTable() &#123; // 存放散列数据的数组，也是散列表 this.table = new Array(137); // 散列函数 this.hash = hash; // 显示散列表中的数据 this.show = show; // 将数据存入散列表 this.put = put;&#125;function hash(data) &#123; // 根据实验设置一个质数 const H = 37; var total = 0; // 对各个字符的所有字母对应的ASCII码值进行求和，并且得到的总和乘以一个质数 for (var i = 0; i &lt; data.length; i++) &#123; total += H*total + data.charCodeAt(i); &#125; // 每个单词的所有字母的ASCII码值的总和对散列数组的长度进行取余 total = total % this.table.length; if (total &lt; 0) &#123; total += this.table.length - 1; &#125; return parseInt(total);&#125;function show() &#123; var n = 0; for (var i = 0; i &lt; this.table.length; i++) &#123; // 判断散列数组里下标为i的存储单元里是否有值，有几打印出来 if (this.table[i] != undefined) &#123; console.log(i + ": "+ this.table[i]); &#125; &#125;&#125;function put(data) &#123; // 将需要存储在散列数组里的数据经过散列函数调用，再将调用后的值作为散列数组的下标保存在一个变量里 var pos = this.hash(data); // 然后在其下标【变量的值】对应的存储空间里存储该数据 this.table[pos] = data;&#125;var someNames = ["yangkun","bobo","jack","kangkang"];// 初始化散列表实例var hTable = new HashTable();for (var i = 0; i &lt; someNames.length; i++) &#123; // 将实例中的数据依次存放在散列数组中 hTable.put(someNames[i]);&#125;hTable.show(); 输出如下图所示 散列表的应用 错误校正【也叫沉余校验】，语音识别，Rabin-Karp字符串搜索算法【平均搜索时间是O(n),这个算法是创建在使用散列来比较字符串的基础上的】，加密【通过散列函数加密】其中语音识别用到了散列函数 MD5 总结 效率特别高，在散列表上插入、删除和取用数据都非常快。但是对于查找操作来说却效率低下，不过查找可以用二叉查找树实现。]]></content>
      <categories>
        <category>JavaScript-Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript-Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react第二节之高质量组件]]></title>
    <url>%2F2017%2F06%2F25%2Freact%E7%AC%AC%E4%BA%8C%E8%8A%82%E4%B9%8B%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[学海无涯苦作舟 组件的命名格式 首字母大写，后面每个单词的首字也大写。 组件划分的原则高内聚 把逻辑紧密相关的内容放在一个组件中。 低耦合 不同组件之间的依赖关系要尽量弱化，也就是每个组件要尽量独立。 组件的数据种类 分为两种：prop 和 state 如何选择 prop是组件的对外接口，state是组件的内部状态。对外用prop，对内用state。 prop 【property】 prop支持的类型非常多，可以是任何一种JavaScript语言支持的数据类型。注意：当prop的类型不是字符串时，在JSX中必须用花括号 {} 把prop值包住。 比如下面代码123&lt;Appstyle = &#123;&#123;color: "red"&#125;&#125;/&gt; 外层花括号代表是JSX的语法，内层的花括号代表这是一个对象常量。 注意事项 一旦prop传入组件后，就不能被修改了。如果需要记录自身数据变化，就必须使用state了。为什么？因为React组件扮演的是render函数的角色，必须是一个没有副作用的纯函数。而修改prop的值，是一个副作用，所以要避免修改。 state 大致步骤：初始化state –&gt; 读取state –&gt; 更新state注意：组件的state必须是一个JavaScript对象,哪怕只是一个数字类型的数据，也只能把它存作state某个字段对应的值。 组件的生命周期装载过程依次调用的函数有： constructor ES6中每个类的构造函数。无状态的组件可以不需要定义构造函数，一个React组件需要构造函数，主要是为了这些目的：初始化state；绑定成员函数的this环境。 getInitialState 这个函数的返回值是用来初始化组件的this.state getDefaultProps 这个函数的返回值作为props的初始值。 注意：getInitialState和getDefaultProps这两个方法在ES6的方法定义的React组件中根本用不到，在ES6中，可以构造函数中通过给this.state赋值完成状态的初始化，通过给类属性defaultProps赋值指定props初始值。 componentWillMount 一般不定义这个函数，因为这个时候没有任何渲染出来的结果，即使调用this.setState修改状态也不会引发重新绘制。这个函数存在的目的主要是为了和componentDidMount对称。注意：既可以在服务器端被调用，也可以在浏览器端被调用。 render 是React组件中最重要的函数，任何一个组件都必须要实现render函数，因为React组件的父类React.Component类对render函数没有默认实现，而其他周期函数都有默认实现。注意：render函数并不做实际的渲染动作，它只是返回一个JSX表示的对象，最终由React来操作渲染过程。有些特殊组件的作用不是渲染界面，那就让render函数返回一个null或者false，这就等于告诉React，这个组件这次不需要渲染任何DOM元素。牢记：React要求render函数只能返回一个元素，如果有多个组件需要render，则需要将这些子组件实例用div包起来。 componentDidMount 当所有组件的render函数都调用后，通过React库把所有组件返回的结果综合起来，知道如何产生对应的DOM修改，这个时候，才会依次调用各个组件的componentDidMount函数作为装载过程的收尾。注意：componentDidMount只在浏览器端执行，因为”装载“是一个创建组件并放到DOM树上的过程，所以是不可能在服务器端完成的，浏览器端渲染不会产生DOM树。componentDidMount被调用的时候，组件已经被装载到DOM树上了。 更新过程 依次调用的函数有：componentWillReceivePropsshouldComponentUpdatecomponentWillUpdaterendercomponentDidUpdate更新过程就不细致说了，感觉没什么好讲的。 卸载过程只调用一个函数： componentWillUnmount 如果在componentDidMount中用非React的方法创造了一些DOM元素而不去处理它，那么就很可能会造成内存泄露，这个就需要在componentWillUnmount中把这些创造的DOM元素清理掉。 总结心得 React的学习曲线还是挺陡峭的，组件涉及到的知识有很多，不过这是基础，要认真去解决组件的每个细节，这样才能为你后面学习React的其他高级知识打下坚实的基础。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime3的经典操作和快捷键]]></title>
    <url>%2F2017%2F06%2F24%2Fsublime3%E7%9A%84%E7%BB%8F%E5%85%B8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器 以下都是在window操作系统下的快捷键【穷，买不起Mac 囧】 最爽的快捷键 可以进行多行选择以及对选择的多行内容进行同时编辑 操作： 把鼠标放到你想要选取的内容上，不必刻意进行全选，只要光标在所选内容上就可以了，然后按 Ctrl + D 那么光标所在的内容将会全部被选中，并且其他的内容会被标记为待选中状态。这个时候再次点击 D 那么下面的第一个带选中的将会被选中。后面再次点击 D 则下面依次被选中。如果选中的不是你想要的，需要跳过某一个内容，继续选择后面的未选中的内容。则需要进行如下操作，Ctrl + D 选中不想要的内容后，按 Ctrl + K 撤销选中，此时你会看到内容还是选中的，没事，这时你按 Ctrl + D 就会看到不想要的内容已经是未选中，并且已经选中了撤销的内容的下面一个待选中的内容了 还有一种可以实现上面的操作： 按住 Shift 然后 按住鼠标右键，进行上下拖动。这个不好说明，只要你按住这两个键，然后试了几下，你就自然知道怎么实现的了。 对于上面两种操作，我的心得体会是： 如果是有内容的，比如你已经写好了三个 if 语句，然后选中三个，那么你可以使用第一种操作。如果是没有内容的，你想在空白处写三个 if 语句，你可以使用第二种操作。 用好这个快捷键，可以极大的提高写代码的效率。 最人性化的保存方式 用其他编辑器，要想使用某一个类型的文件，需要点击保存，然后弹出命名文件和类型的窗口。用sublime3就可以很完美的使用 Ctrl + n 新建文件，不需要点击保存来选择文件类型，新建后文件格式默认是 text 格式，你可以在界面的右下角看到 Plain Text 字样。这时候按住快捷键 Ctrl + Shift + P 后，会弹出一个对话框，此时输入相应的文件名后缀，就会出现对应的格式选项，选择后，按回车键即可发现文件已经是你想要的格式类型了，后面就可以随心所欲的使用对应文件类型的语法提示了。 最完美的扩展插件机制这个就不说了，插件安装可以网上搜一下。我个人觉得上面两个内容是我最喜欢sublime的原因。]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之贪心算法]]></title>
    <url>%2F2017%2F06%2F24%2FJS%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概念贪心法就是遵循某种规则，不断贪心地选取当前最优策略的算法设计方法。贪心算法总是会选择当下的最优解，而不去考虑这一次的选择会不会对未来的选择造成影响。 使用贪心算法的思路 使用贪心算法通常表明，实现者希望做出的这一系列局部“最优”选择能够带来最终的整体“最优”选择。如果是这样的话，该算法将会产生一个最优解，否则，则会得到一个次优解。对于很多问题来说，寻找最优解很麻烦，这么做不值得，所以使用贪心算法就足够了。 代码如下 下面用找零做例子 有1元、5元、10元、25元的整钞，先用这些整钞支付66元，最少需要多少张整钞？ 123456789101112131415161718192021222324252627282930313233343536373839404142function makeChange(origAmt, coins) &#123; // 初始化表示剩下的余额，开始设置为0 var remainAmt = 0; if (origAmt % 25 &lt; origAmt) &#123; coins[3] = parseInt(origAmt / 25) remainAmt = origAmt % 25; origAmt = remainAmt; &#125; if (origAmt % 10 &lt; origAmt) &#123; coins[2] = parseInt(origAmt / 10) remainAmt = origAmt % 10; origAmt = remainAmt; &#125; if (origAmt % 5 &lt; origAmt) &#123; coins[1] = parseInt(origAmt / 5) remainAmt = origAmt % 5; origAmt = remainAmt; &#125; coins[0] = parseInt(origAmt / 1);&#125;function showChang(coins) &#123; if(coins[3] &gt;0 )&#123; console.log("该硬币的数量是："+coins[3]+" "+"总面值为："+ coins[3]*25); &#125; if(coins[2] &gt;0 )&#123; console.log("该硬币的数量是："+coins[2]+" "+"总面值为："+ coins[2]*10); &#125; if(coins[1] &gt;0 )&#123; console.log("该硬币的数量是："+coins[1]+" "+"总面值为："+ coins[1]*5); &#125; if(coins[0] &gt;0 )&#123; console.log("该硬币的数量是："+coins[0]+" "+"总面值为："+ coins[0]*1); &#125; &#125;var origAmt = 66;var coins = [];makeChange(origAmt, coins);showChang(coins); 输出如下 心得体会贪心算法很好理解，很经典，掌握其核心：只关注当下的最优解 深刻理解就可以很好的运用贪心算法了。]]></content>
      <categories>
        <category>JavaScript-Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript-Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之动态规划]]></title>
    <url>%2F2017%2F06%2F23%2FJS%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[概念动态规划方案通常会用一个数组来建立一张表，用于存放被分解众多子问题的解。当算法执行完毕，最终的解将会在这个表中很明显的地方找到。 动态规划与递归的联系联系：动态规划有时被认为是一种与递归相反的技术。递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整个问题。动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个整体方案，从而解决掉整个大问题。 使用思路 使用动态规划设计的算法应该从它能解决的最简单的子问题开始，继而通过得到的解，去解决其他更复杂的子问题，直到整个问题都被解决。所有子问题的解通常被存储在一个数组里以便于访问。 代码如下 用斐波那契数列做例子。1234567891011121314151617181920212223242526272829303132333435function dynFib(n) &#123; // 定义val数组来保存中间结果 var val = [] for (var i = 0; i &lt;= n; i++) &#123; val[i] = 0; &#125; // 如果斐波那契数是1或者2，则返回1 if (n==1 || n==2) &#123; return 1; &#125; // 否则，把数值1和2保存在val数组中1和2的位置 else&#123; val[1] = 1; val[2] = 2; // 从3开始，将数组中的每个元素赋值为前两个元素只和，直到循环结束 for (var i = 3; i &lt;= n ; i++) &#123; val[i] = val[i-1] + val[i-2]; &#125; // 返回数组的最后一个元素即为最终计算的斐波那契数值 return val[n-1]; &#125;&#125;var start = new Date().getTime();console.log(dynFib(30));var stop = new Date().getTime();var result = stop - start;console.log("用时为： "+result+"毫秒"); 输出如下 心得体会更深刻的理解了递归的效率为什么很低，就是因为有太多值在递归调用中被重新计算。下面一张图就可以说明它的工作效率为什么这么差。上图是斐波那契函数生成的递归树，从图中就可以看出重复计算了很多值。 如果编译器可以将已经计算的值记录下来，函数的执行效率就不会很差。动态规划就是用一个数组来存储已经计算过的值，以此来提高效率。]]></content>
      <categories>
        <category>JavaScript-Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript-Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS算法之二分查找算法]]></title>
    <url>%2F2017%2F06%2F23%2FJS%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[概念字面意识上就是 使用前提数据要是有序的，对无序的数据无效。 步骤1：将数组的第一个元素的位置设置为下边界【0】2：将数组的最后一个元素的位置设置为上边界【数组的长度减1】3：若下边界等于或小于上边界，则作如下操作。 a. 将中点设置为【上边界加下边界】除以2. b. 如果中点的元素小于查询的值，则将下边界设置为中点元素所在下标加1。 c. 如果中点的元素大于查询的值，则将上边界设置为中点元素所在下标减1。 d. 否则中点元素即为要查找的数据，可以进行返回。 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function binSearch(arr, data) &#123; // 上界 var upperBound = arr.length-1; // 下界 var lowerBound = 0; while (lowerBound &lt; upperBound) &#123; // 取中值 var mid = Math.floor((lowerBound+upperBound)/2); // 改变上界或者下界的值 if(arr[mid] &lt; data)&#123; lowerBound = mid + 1; &#125;else if(arr[mid] &gt; data)&#123; upperBound = mid - 1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125;var nums = [];for (let i = 0; i &lt; 100; i++) &#123; // 0到100的整数 nums[i] = Math.floor(Math.random()*100);&#125;// 对数组排序var sortNums = nums.sort();// 不换行打印排序后的数组console.log(sortNums+" ");// 设置需要找的数据var val = 38;// 调用二分查找函数var retval = binSearch(sortNums,val);// 判断是否存在，存在的话将位置打印出来if (retval &gt; 0) &#123; console.log("已经找到"+val+"所在位置为：" + retval);&#125; else &#123; console.log(val + "没有出现在这个数组中");&#125; 输出如下 心得体会 对于二分查找法需要有序数据的这个前提条件感到不太满意，无形中是效率变低。不过相对于顺序查找，在处理大数据集时，速度要明显快。因为决定算法性能的每一步循环嵌套中，二分查找减少了一半的查找量（数组中的元素）。]]></content>
      <categories>
        <category>JavaScript-Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript-Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react第一节之必知概念]]></title>
    <url>%2F2017%2F06%2F22%2Freact%E7%AC%AC%E4%B8%80%E8%8A%82%E4%B9%8B%E5%BF%85%E7%9F%A5%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[命名由来 React践行的是“响应式编程”思想，也就是 Reactive Programing React 的核心思想通过组件来开发应用。 组件所谓组件，指的是能完成某个特定功能的独立的、重用的代码。 基于组件的应用开发是广泛使用的软件开发模式。 JSX全称：JavaScript eXtension目的：让我们可以在JS中编写像HTML一样的代码。一种JavaScript的数据结构，不是真正的HTML，也和DOM没有关系，其实就是React.createElement写法的语法糖，是快速高效书写这个函数的方法，它返回的是ReactElement。 JSX不能直接在浏览器中使用，需要转义成标准的JS语法，而JS编译器Babel就是目前最好的JSX的转义工具。 Babel是什么：一个JavaScript编译器。作用：一个是让代码支持ES6的语法，一个是支持React的一些特性（例如JSX语法）。 Virtual DOM 【虚拟DOM】目的：尽量减少DOM操作每个React组件都是用虚拟DOM渲染的。 DOM树是对HTML的抽象，那Virtual DOM就是对DOM树的抽象。组件的DOM结构映射到虚拟DOM上，当需要重新渲染组件时，React在虚拟DOM上实现了一个 Diff 算法，通过这个算法寻找需要变更的节点，再把里面的修改更新到实际需要修改的DOM节点上，这样就避免了整个渲染DOM带来的巨大成本。 ##]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《暗时间》读书笔记]]></title>
    <url>%2F2017%2F06%2F21%2F%E6%9A%97%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[波普尔曾经说过：人生不过是解决问题。 挑几个重要的收获说吧： 你比别人往后多看一年，你就比别人领先一年的时间来准备。 思考问题，去追寻答案的时候，一定要学会联想。 一定不要把简单的事情搞复杂。 遇到问题一定要自己动手，不要直接问答案。 坚持写博客，记录笔记，与自己对话。 找到你的不可替代性和核心竞争力。 兴趣遍地都是，专注和持之以恒才是真正稀缺的。 过早退出是一切失败的根源。 生活中的选择远比我们想象的要多，细微的选择差异造就了不同的人生。 一生的知识积累，自学的起码占90%]]></content>
      <categories>
        <category>reading-note</category>
      </categories>
      <tags>
        <tag>reading-note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法的本质]]></title>
    <url>%2F2017%2F06%2F20%2F%E7%AE%97%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[本质算法本质上可以看做是在一个解空间当中的搜索问题，所以要分析一个算法的好坏，首先要弄清它的解空间的结构，然后分析它是怎么来探索这个解空间的。 如何弄清解空间 举个例子，例如排序算法，其解空间可以看做是所有可能的下标排列组合，其中有且仅有一个排列是正确的排序排列，这里假设元素各不相同，那么一个算法在探索这个解空间方面的行为就决定了它的效率高低，最简单的，如果一个算法每次都只能检查解空间中的一个点，那么这个算法的复杂度就是解空间的大小。 对排序算法而言也就是 n! 。从这个角度来看，我们很容易地发现，所有基于比较的排序算法，其复杂度为什么是以O(nlogn)为下界的，因为一次比较操作最多有两个结果，a&gt;b或b&gt;a，既然只有两种结果，那么最多只能将空间进行二分，如果每次都能完美地二分，那么找到那个唯一点最终需要的步骤就是log(n!) = O(nlogn)。这样就不难理解为什么基于比较的排序算法的复杂度最好不过如此了。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包和定时器的终极面试题]]></title>
    <url>%2F2017%2F06%2F12%2F%E9%97%AD%E5%8C%85%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E7%BB%88%E6%9E%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最基础的问题123for (var i = 0; i &lt; 3; i++) &#123; console.log(i);&#125; 输出如下 这个很好理解的，没有任何异步操作，按部就班的一次显示0 1 2 升级一层能力12345for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;,1000)&#125; 输出如下 我是将这段代码直接写在控制台上，于是先输出了一个随机数字，然后等待了一秒后立即输出了 3 3 3 ,如果将代码嵌入到HTML页面中，则不会有随机数字出现，其他结果都一样。将这段代码在控制台上再输出几次，发现随机数字依次加3。 为了更好理解，加个时间戳来更好的显示时间差，可以这样写1234567for (var i = 0; i &lt; 3; i++) &#123;console.log(new Date()); setTimeout(function () &#123; console.log(i); console.log(new Date()); &#125;,1000)&#125; 输出如下 很明显，先调用for循环立即连续输出三个时间，然后一秒以后三个定时器同时输出。 再次升级12345for (let i = 0; i &lt; 3; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;,1000)&#125; 12345678for (var i = 0; i &lt; 3; i++) &#123; (function (i) &#123; setTimeout(function() &#123; console.log(i); &#125;,1000) &#125;)(i);&#125; 上面两个代码依次输出如下 对于第一个for函数，可以这样写12345678for (let i = 0; i &lt; 3; i++) &#123; var a = new Date(); setTimeout(function() &#123; console.log(i); var now = new Date(); console.log(now - a); &#125;,1000)&#125; 输出如下 从输出结果看，块级作用域，将i限制在块级作用域中，也就是不会被覆盖，为什么不会覆盖，因为浏览器会把块级作用域内的变量值另存起来，这点很重要。执行过程还是一样，一秒钟后立即输出1 2 3 终极进阶1234567891011for(var i = 0; i &lt; 3; i++) &#123; setTimeout( (function(i) &#123; return function() &#123; console.log(i); &#125; &#125;)(i), (function(i) &#123; return i * 1000; &#125;)(i) );&#125; 输出如下 上面的代码加个时间戳可以改成这样12345678910111213for(var i = 0; i &lt; 3; i++) &#123; var a = new Date(); setTimeout( (function(i) &#123; return function() &#123; var now = new Date(); console.log(i, now - a); &#125; &#125;)(i), (function(i) &#123; return i * 1000; &#125;)(i) );&#125; 输出如下 这是最终极的写法了，这样更好的表示了其中时间的过程。三个定时器是同时计时的，第二个计时器是2s，也就是在第一个定时器等待1s输出后，第二个定时器在1s后就会输出。]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之快速排序]]></title>
    <url>%2F2017%2F05%2F19%2F%E7%AE%97%E6%B3%95%E7%95%8C%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[概念一种分而治之的算法，通过递归的方式依次分解为包含较小元素和较大元素的不同子序列。然后不断重复这个步骤直到所有数据都是有序的。 时间复杂度平均时间复杂度为O(nlogn) 算法步骤1：选择一个基准元素，将列表分隔成两个子序列；2：对列表进行重新排序，将所有小于基准值的元素放在基准值的前面，所有大于基准值的元素放在基准值的后面；3：分别对较小元素的子序列和较大元素的子序列重复步骤1和2。 代码如下 123456789101112131415161718192021222324252627282930313233function qSort(list) &#123; if (list.length==0) &#123; return []; &#125; //定义一个基准值 var pivot = list[0]; //用于放小于基准值的元素的数组 var lesser = []; //用于放大于基准值的元素的数组 var greater = []; for (let i = 1 ; i &lt; list.length; i++) &#123; if (list[i]&lt;pivot) &#123; lesser.push(list[i]); &#125; else &#123; greater.push(list[i]); &#125; &#125; //使用了递归,将lesser数组、基准值pivot和greater数组依次连接起来构成新的数组 return qSort(lesser).concat(pivot,qSort(greater));&#125;var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = Math.floor((Math.random()*10)+1);&#125;console.log(a);console.log(qSort(a)); 输出如下 心得根据我的测试，快速排序算法非常适用于大型数据集合，可是在处理小数据集合时性能反而会下降。]]></content>
      <categories>
        <category>JavaScript-Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript-Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之冒泡排序]]></title>
    <url>%2F2017%2F05%2F10%2FJS%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序 通俗的说就是把一堆数放进有序数组里，然后从第一个数开始，依次比较自己和后一个数的值，如果需要输出升序排列，那就要把大的数放在后面，于是很自然的想到如果自己比后一个数大，那就要互相交换值，如果不大，则不需要交换。依次往后循环即可完成升序排序。降序排列同理。 算法步骤1：比较相邻的元素。如果第一个比第二个大，就互相交换。 2：对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。做完后，最后的元素会将是最大的数。 3：针对所有的元素重复以上的步骤，除了最后一个。 JS代码如下：123456789101112131415function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; console.log(arr);&#125;bubbleSort([5,4,3,2,1]); 将上面程序保存名为 bubbleSort 的 js 文件，然后进入 bubbleSort 所在的目录下，用 node bubbleSort.js 命令运行程序，结果如下图。 算法性能分析 由于嵌套两层 for 循环，导致时间复杂度为 O(n2)，n2 是 n 的平方的意识。当 n 很大的时候，性能非常差。所以仅仅只适合 n 很小的情况。]]></content>
      <categories>
        <category>JavaScript-Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript-Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底征服闭包定义、特点、价值、用法]]></title>
    <url>%2F2017%2F04%2F10%2F%E5%BD%BB%E5%BA%95%E5%BE%81%E6%9C%8D%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包的定义与含义 闭：是指闭包的内部环境对外部不可见。 闭包具有控制外部域的能力，也就是可以访问外部环境的执行域，，同时又能防止外部域对闭包的反向控制，也就是说，闭包的领域是对外封闭的。 闭包的实现方法 JS闭包是通过function实现的 闭包的特权 闭包内声明的变量，闭包外的任何环境都无法访问。举个栗子：12345678910function f1()&#123; var a=10; var b=20; function f2()&#123; console.log(a); &#125;; return f2;&#125;var result =f1();result(); 这里的闭包是f1函数，不懂没关系，下面我会运用这个例子上面写的知识来去解释为什么f1是闭包。 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的，但是反过来就不行，f2内部的局部变量对f1就是不可见的。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们就可以在f1外部读取它的内部变量！这种函数叫称之为闭包函数。所以，这个困扰初学者到底哪个是闭包的问题也就解决了，顺着这个思路你就会发现变量a和变量b也是闭包的一部分，因为他们对外不可见。所以这个代码例子的闭包部分是123var a=10; var b=20;function f2()&#123;&#125;; JS垃圾回收机制这里为了让小伙伴们更好的理解闭包，我顺带把JS垃圾回收机制说一下，尽量用通俗简单的话语解释。一句话定义：JS垃圾回收机制规定：当你调用完一个函数后，他就不存在了 举个栗子：1234function aaa() &#123; var a =1; &#125;aaa(); 上面这段代码当函数aaa调用完【aaa();这句就是指函数调用】，那么变量a也就不存在了，它所占的内存就被JS垃圾回收机制给回收了。 那么怎样才能不能JS垃圾回收机制回收呢？也就是让变量a在内存中呆的时间久一点，别一执行完函数就消失了。 解决这个问题就是要运用闭包的特性。 闭包的特点函数嵌套函数内部函数可以引用外部函数的参数和变量,这样就会使参数和变量不会被垃圾回收机制所收回 举个栗子：1234567function f3(a)&#123; var b=1; function f4()&#123; alert(a); alert(b); &#125; &#125; 上面栗子可以看出，函数f4内部引用了外部函数f3的参数a和局部变量b这样函数执行完以后，参数和变量都不会被垃圾回收机制回收。 下面再看一个栗子【首先说明，下面这个栗子很明显不是闭包】1234567function aaa()&#123; var a =1; a++; console.log(a); &#125;aaa();aaa(); 上面代码的执行结果如图： 调用两次的结果都是2，变量a并没进行累加，说明在调用第一次函数aaa后，变量a【值为2】已经销毁了，第二次调用后，变量a又会重新从1加到2进行输出。1234567var b =1;function bbb()&#123; b++; console.log(a); &#125;bbb();bbb(); 调用两次的结果:第一次是2，第二次是3，为什么呢，因为变量b是全局变量，是定义在全局作用域下的【简单点解释就是全局变量，做大的一个作用域】当函数bbb执行完后，虽然函数bbb里的东西销毁了，但是在全局作用域中，变量b还存在，就导致了变量b没有被销毁，继续存在，于是就会一直累加。从这里再次对比上一个栗子，变量a是局部变量，也没有在外部域存在，所以执行完函数aaa后，就会被销毁。 那么如何才能既让a是局部变量，又能让a累加呢？ 这就是闭包最拿手的事情!! 栗子如下： 1234567891011function aaa() &#123; var a = 1; return function() &#123; a++; console.log(a); &#125; &#125; var c = aaa(); c(); c(); alert(a); 执行完以后显示如图：第一次调用结果为2，第二次调用结果为3，成功实现了既让a是局部变量，又能让a累加的功能。同时你看到了上面，变量a未定义，对，你没有看错，我在全局作用域中了加了一句alert(a)，结果表明外部域是无法访问到内部域的变量a的。现在是不是有点慢慢通窍了，有种茅塞顿开的感觉了吧。 最后用一句话定义闭包：函数内在包含子函数，并最终return子函数。 12345678910function f1()&#123; var a=10; var b=20; function f2()&#123; console.log(a); &#125;; return f2;&#125;var result =f1();result(); 闭包函数的最大价值在于：我们可以在函数(f2)的外部（即子函数也就是f2函数），直接读取该函数的局部变量。 再深入研究，就会发现f1()函数就如同一个“类”，而其定义的局部变量就如同该“类”的全局变量；而子函数f2()函数，则如同这个“类”的方法，可以直接使用这个“类”的全局变量n 闭包到底有什么用？1、缓存：显而易见，就是可以实现数据缓存，我们可以把一个需要长期用到的变量设为闭包函数的局部变量，在子函数里面直接使用它。因此局部变量只定义初始化一次，但我们可以多次调用子函数并使用该变量。这比起我们在子函数中定义初始化变量，多次调用则多次初始化的做法，效率更高。闭包函数常见的一种用途就是，我们可以通过此实现计数功能。在闭包函数定义一个计数变量，而在子函数中对其进行++的操作。这样每次调用闭包函数，计数变量就会加1。 2、实现封装：如前面所说，闭包函数就如同一个“类”，只有在该闭包函数里的方法才可以使用其局部变量，闭包函数之外的方法是不能读取其局部变量的。这就实现了面向对象的封装性，更安全更可靠。 闭包的知识我先说到这里，虽然有一些很重要的细节我没有说，比如，怎么改进这个闭包的书写形式来达到更好的模块化，其实是关于函数的知识，我不想在闭包上把很多细节都扯了，这篇文章对于你理解闭包已经没有问题了，毕竟在这个碎片化时间的世界里，一篇文章不能太长，这里其他的知识我先不说了，过几天我写一篇征服JS函数的文章，再结合这个把闭包彻底搞透。]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX的日常使用方法]]></title>
    <url>%2F2016%2F12%2F27%2FAJAX%E7%9A%84%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[翻译 Asynchronous JavaScript XML 定义 无需刷新页面就能从服务器获得数据的一种方法。 思路 使用XHR对象取得新数据，再通过DOM将新数据 插入到页面中。 具体步骤第一步检测原生XHR对象是否存在 第二步1var xhr = createXHR(); 第三步1xhr.open("get","example.php",true); 调用open()方法，不会真正发送请求，只是启动一个请求以备发送。注意：参数 true 是异步请求方式，对应的 false 是同步请求，用AJAX的目的就是为了异步请求，所以我们基本都是用 true 做参数 get方式：把数据放到网址url()里提交 —-&gt; 安全性很低 —-&gt; 容量很低，只有几K，几M 。post方式：把数据放到 html:content 里提交 —-&gt; 安全性一般 —-&gt; 容量很高，几乎无限。get主要用来获取，会缓存，便于分享，也就是把网址复制给别人。post主要用来提交上传数据，不会缓存。 第四步1xhr.send(); 发送特定的请求，发送以后，请求就会被分配到服务器。 结果 服务器收到请求后会发出一个响应给XHR对象，然后自动填充xhr的属性。填充xhr的属性主要有: responseTest responseXML status statusText 下面是 AJAX 异步请求代码 1234567891011121314var xhr = createXHR();xhr.onreadystatechange = function() &#123; if (xhr.readystate == 4) &#123; if (xhr.status &gt;= 200&amp;&amp;xhr.status &lt; 300 || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful:"+ xhr.status); &#125; &#125;&#125;xhr.open("get","example.php",true);xhr.send(); AJAX扩展可以自定义请求头部信息：1setRequestHeader(); 上面这个方法要放在xhr.open()和xhr.send()之间。用下面方法可以取得所有头部信息1xhr.getAllRequsetHeaders();]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站性能优化总结]]></title>
    <url>%2F2016%2F12%2F20%2F%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[追求极致性能的原则第一点：减少Http请求次数。第二点：减少DOM操作次数。第三点： 少用全局变量，缓存DOM节点查找的结果，减少IO读取操作。第四点： 图片预加载。第五点： 避免使用动态属性，比如CSS表达式。第六点： 使用雪碧图技术。第七点： CSS压缩，JS压缩技术。第八点： 对于不经常更新的数据使用浏览器缓存。第九点： 使用CDN内容分发技术。]]></content>
      <categories>
        <category>FE-Performance-Optimization</category>
      </categories>
      <tags>
        <tag>FE-Performance-Optimization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解开Return的奥秘]]></title>
    <url>%2F2016%2F12%2F15%2F%E8%A7%A3%E5%BC%80Return%E7%9A%84%E5%A5%A5%E7%A7%98%2F</url>
    <content type="text"><![CDATA[苦恼 每次写JS代码的时候总是会遇到各种return语句，很头疼。最近整理了return的各种隐蔽的知识，写下总结分析出来。 举个例子1return false; 上面一句代码到底有几层含义第一层含义：只是对当前函数有效，并不会影响其他函数的执行。第二层含义：阻止默认事件行为。 比较下面两段代码12345function call() &#123; var b = 2+3; return b;&#125;console.log(call()); 输出入下：call函数用return语句返回一个表达式结果，然后调用call函数打印结果值。 1234function call() &#123; var b = 2+3;&#125;console.log(call()); 输出入下：call函数没有写return语句来返回一个值，那么这个call函数返回的结果是undefined，所以打印call函数调用的结果是undefined。 总结： return 后面的语句不会再执行【仅限return所在的函数中】如果函数有一个结果，然后调用这个函数，则需要在函数中return来保存函数结果。]]></content>
      <categories>
        <category>JavaScript-CSS-HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git知识总结]]></title>
    <url>%2F2016%2F08%2F10%2Fgit%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[遇到的所有问题：1：warning: LF will be replaced by CRLF in XXXXXXXXXXXXXX.解决 git config core.autocrlf false 2：github push 提交代码时停止在writing objects怎么办？git config –global http.postBuffer 524288000 3：新建仓库初始化时，不要点击初始化按钮，否则github就自动建立一个git仓库，并且生成一个版本库所以这样的话，那你用git push origin master就会说被拒绝这种情况要先git pull origin master再git push origin master 一开始怎么绑定github账号设置全局用户名和email，作为每次提交的记录git config –global user.name “name”git config –global user.email “mail.com” 添加一个仓库git remote add origin git@….gitgit push -u origin master 当提示权限不够时，添加ssh公钥在用户的.ssh目录下找id_rsa.pub等文件，没有的话去生成ssh-keygen -t rsa -C “youremail@example.com” 设置pull的默认地址git branch –set-upstream-to=origin/master 设置push的默认地址git remote add origin git@….git 配置别名git config –global alias.xx ‘’ 临时保存工作区git stashgit stash pop 回滚git reset —hard 版本号 强行回滚远程服务器git push -f 手动创建git忽略push清单1.文件夹内右键git bash，输 touch .gitignore，注意中间有空格2.编辑器打开生成的 .gitignore 文件，加入.gitignorenode_modules3.保存]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>