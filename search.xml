<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA核心技术英语原版阅读完之第五章英语单词翻译]]></title>
    <url>%2F2017%2F07%2F05%2FJAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%8B%B1%E8%AF%AD%E5%8E%9F%E7%89%88%E9%98%85%E8%AF%BB%E5%AE%8C%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[学海无涯苦作舟以下单词的出现顺序是按照看书的页面遇到单词的的顺序为标准的]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>英语原版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看见程序语言的精髓第二篇]]></title>
    <url>%2F2017%2F07%2F03%2F%E7%9C%8B%E8%A7%81%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B2%BE%E9%AB%93%E7%AC%AC%E4%BA%8C%E7%AF%87%2F</url>
    <content type="text"><![CDATA[程序员的三大美德：懒惰，急躁和傲慢。透过现象看本质，语言的核心都是一样的，知道其本质才能以不变应万变。 为什么要取名字变量和函数为什么要有名字？回答这个问题其实很简单，但是很多人根本没有想过这个问题，连质疑的态度都没有。 回顾一下，没有发明命名名字以前，计算机是通过编号来代表计算机记录数据的存储位置，例如“123号的数值加1”这样的计算机指令。 对于上面的编号来说，很显然使用名字的指定方法要方便很多。 程序可读性提高，就像给孩子起名字一样，起名以后，你只需要名字就可以确定你的孩子，程序也是一样。我喜欢把名字看成二维码，之前的编号相当于钥匙，还要开门，而现在二维码只需要扫一下就好了。 为什么要有作用域？ 作用域是什么，为什么要有作用域，设置作用域的目的是什么？ 上面说了给函数和变量起名字会非常方便，但是如果名字起冲突了怎么办，总不能所有名字都不是一样的吧，很明显这是不可能的，也不现实。这个时候计算机科学家就想到了设置作用域来解决这个问题。 作用域是什么？简单点说就是指名字的有效范围，将名字的有效范围限定在更小的范围内，出了这个范围，名字则会无效。基于这个思路，提出了作用域的概念。 作用域分类 动态作用域 静态作用域 容器顾名思义，容器就是用来存放东西的，在程序语言中，把存放多个元素的东西称为容器。 容器中的数据容器中的数据实际上是存放在内存中的。容器的类型不同，内存中存储数据的方式也不同。 如何选择容器首先说一下，没有万能的容器。 根据容器的使用目的，使用方式和操作类型的不同，最适宜的容器类型也会相应地变化。核心：在节约内存和节约计算时间之间寻找最佳平衡。 字符和编码的真相字符其实字符只不过是人们预定好的命名为字符的一系列符号的集合而已。这一符号的集合称为字符集或者字符包，字符集因国家和文化而千差万别。 编码将字符集通过数字化的数据表现出来，就必须考虑如何对字符进行编码。注意：编码方式只不过是人们约定的一系列规则，有些可能是随意决定的！编码方式必须为字符编码方和编码解码方共有，和没有掌握这一编码方式的人是无法进行信息交互的。Unicode：包含世界上所有字符的字符集合。而UTF-8是：一种用来编码Unicode这样统一之后的字符集的编码方式。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程精髓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA核心技术英语原版阅读完之第四章英语单词翻译]]></title>
    <url>%2F2017%2F07%2F02%2FJAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%8B%B1%E8%AF%AD%E5%8E%9F%E7%89%88%E9%98%85%E8%AF%BB%E5%AE%8C%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0%E9%83%A8%E5%88%86%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[学海无涯苦作舟以下单词的出现顺序是按照看书的页面遇到单词的的顺序为标准的predefined : 预定义oriented : 面向hints : 建议，提示procedural languahes : 程序语言dominant : 优势paradigm : 范例off-the-shelf : 现成的appropriate : 合适的manipluating : 操纵breakdown : 分解grasp : 把握cookie cutters : 饼干模具Encapsulation : 封装 invoke : 调用reuse : 重用reliablity : 可靠性tenet : 信条obtain : 获得resemblance : 相似spontaneously : 自发distinct identity : 独特的身份new-comers : 新来者a simple rule of thumb : 一个简单的经验法则correspond : 对应nouns : 名词verbs : 动词dependence : 依赖aggregation : 聚合inheritance : 继承minimize : 最小化the point is : 重点是 containment : 遏制methodologists : 方法论disdain : 蔑视alternatively : 或者representation : 表示coordinate : 协调behalf : 代表sophisticated ；复杂yields : 产生dissecting : 分析implicit : 隐式explicit : 显式guarantee : 保证corrupted : 破坏culprit : 祸首messing up : 搞乱mutator : 突变，改变tedious : 乏味的rare : 罕见primitive : 原始ultimately : 最终whatsoever : 任何trivial : 不重要的somewhat : 有些opted : 选择trick : 技巧 mechanism : 机制arbitrary : 随意encounter : 遭遇entity : 实体smuggle : 走私nested : 嵌套document : 做动词是记录的意识]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>英语原版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻松github-pull-request]]></title>
    <url>%2F2017%2F07%2F01%2F%E8%BD%BB%E6%9D%BEgithub-pull-request%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器 PR先将仓库下载到本地开发环境中1git clone git@github.com:godkun/godkun.github.io.git 就是下图这个地址，换成你的地址就可以 然后进入你的仓库目录中1cd godkun.github.io PR的时候要养成建特性分支后再修改代码的习惯查看仓库的分支1git branch -a 会在终端显示当前的分支名然后创建特性分支1git checkout -b 新的分支名&amp;emsp;当前的分支名 再次使用1git branch -a 查看是否转换分支成功 提交代码编辑完仓库中的代码后，输入1git diff 查看修改是否正确进行 然后进行1git add 修改的文件 再1git commit -m "这是第一次pull request" 创建本地新建分支对应的远程分支1git push origin 新建分支 然后查看分支1git branch -a 发送Pull Request登录github并切换到 对应仓库的 新建分支 ，点击 New pull request再然后,点击 Create pull request 总结 你已经成功完成了一次具有历史意义的征服github的关键一步了。继续加油吧少年。如果有不懂的可以问我 个人联系方式 QQ:357821351 邮箱：godkun666@126.com github地址: https://github.com/godkun]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发中遇到的陌生英文单词【一直更新】]]></title>
    <url>%2F2017%2F07%2F01%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%99%8C%E7%94%9F%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E3%80%90%E4%B8%80%E7%9B%B4%E6%9B%B4%E6%96%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[运用webpack,&emsp;react 过程中遇到的单词enforce : 执行omit : 忽略customize : 定制pinned : 固定API schema ；API模式emit : 发射chunk : 块hot module replacement : 热模块交换component : 组件loader : 加载器encrypt : 加密]]></content>
      <categories>
        <category>单词翻译</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>英文单词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从存储结构来看JS代码执行的本质]]></title>
    <url>%2F2017%2F06%2F30%2F%E4%BB%8E%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%9D%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[存储体的结构组成 用原型制作工具制作的下面这个简单的示意图。 上图的解释上图是一个存储体的结构，其中 CS 这段称为 域 其大小在程序运行前就已经确定。堆 这段需要人工申请，用 new 方式申请，可以将堆看成一棵树。栈 系统自动分配，先进后出。 下面我用一个例子来解释JS代码在内存中是怎么分配的12345678910111213function Person(id, name, age) &#123; this.id = id; this.name = name; this.age = age;&#125;var num = 10;var bol = true;var str = "abc"; var obj = new Object();var arr = ['a','b','c'];var person = new Person(100, "godkun", "21"); 对上面代码进行解释我在纸上画图手写了这个笔记，如下图 图中左边是栈，右边是堆，在JS中，一般基本变量是把变量名和值一起放在栈中，这样可以提高速度，而引用类型则是把变量名放在栈中，把数据放在堆中。通过栈引用访问堆中数据。 注意：这里我要特别说明一点，从图中看到堆的最外面有个“围墙”，所以无法直接操作存储在堆中的数据，必须通过栈的引用来操作堆中的数据，也就是栈引用堆。 总结栈和堆栈优势：存取速度比堆要快 ，速度仅小于CPU中的寄存器。劣势： 数据的大小和生存期必须是确定的，缺乏灵活性。 堆优势： 动态分配内存大小，生存期也不必事先告知编译器，垃圾收集器会自动收集这些不再使用的数据。劣势： 由于运行时动态分配内存，所以速度慢。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JS，存储结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看见程序语言的精髓第一篇]]></title>
    <url>%2F2017%2F06%2F29%2F%E7%9C%8B%E8%A7%81%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B2%BE%E9%AB%93%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[程序员的三大美德：懒惰，急躁和傲慢。透过现象看本质，语言的核心都是一样的，知道其本质才能以不变应万变。 黎明的前奏—语法没有那么神秘，语言设计者制定的规则就是语法。比如 1+2*3 表达式，它的结果可以是7，也可以是9，这取决于语言制定者怎么规定的语法，怎么方便，怎么规定。所以对于大家来说，结果是7更好理解，也就更方便。这就是语法。 语法分析器 语法分析器是把源代码作为字符串读入，解析，并建立语法树的过程。 函数的诞生 我个人觉得就是因为需要重复调用，而函数正好满足这一要求，它可以把结果存在返回值，然后在你需要的时候去调用它，有着非常高的可复用性。 错误异常处理代码为什么那样写这里个背景知识：一个大佬在论文中提出了一种更好的异常处理的方法，大致内容如下一是明确声明命令可能抛出何种异常，二是需要有将可能出错的操作括起来的语句结构。 这个论文直接导致了现在大部分的语言都采用了先括起来可能出错的操作，再编写错误处理的语句结构。 现在最经典的异常处理结构语言如下：1234567try&#123; /* 可能出错的代码 */&#125; catch(...) &#123; /* 异常处理代码 */&#125; finally &#123; /* 必将执行的代码 */&#125; 这里说一下为什么要加一个finally语句，因为如果不加一个必将执行的代码的话，那么这个被调用的函数如果在多处都有抛出异常的可能性，就会导致在很多地方都有可能跳出这个函数，此时就会出现函数调用过程不完整。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程精髓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA核心技术英语原版阅读完之第三章部分英语单词翻译]]></title>
    <url>%2F2017%2F06%2F29%2FJAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%8B%B1%E8%AF%AD%E5%8E%9F%E7%89%88%E4%B9%8B%E9%83%A8%E5%88%86%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%AF%91%E3%80%90%E4%B8%80%E7%9B%B4%E6%9B%B4%E6%96%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[学海无涯苦作舟以下单词的出现顺序是按照看书的页面遇到单词的的顺序为标准的machinery : 机器illustrate : 说明skimming ：略读denote : 声明，表示customary : 约定好的precision : 准确fractional : 部分的explicit : 明确的conceptually : 从字面（概念）上看naturally enough : 当然quoted : 引用的 preceding : 前面的overall : 总体outweighs : 比重inefficiency : 无效率的extracting : 提取exception : 例外，异常assembling : 组合lest : 免得intermittent : 断断续续的hold : 保留，保持supplementary : 补充keystrokes : 按键disposal : 处置humble : 谦卑delimited : 划分directive : 命令 backslash : 反斜杠clause : 子句attach : 连接specifies ； 指定unwritten : 不成文的enhanced ； 增强concise : 简洁error-prone : 容易出错pesky : 讨厌traverse the entire collection : 遍历整个集合shortcut : 捷径]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>英语原版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件式开发APP全站流程]]></title>
    <url>%2F2017%2F06%2F28%2F%E7%BB%84%E4%BB%B6%E5%BC%8F%E5%BC%80%E5%8F%91APP%E5%85%A8%E7%AB%99%2F</url>
    <content type="text"><![CDATA[总结 自己看了一些视频，然后总结了一下，在纸上总结了开发APP全站的全流程。 流程为：产品 —-&gt; 美工 —-&gt; 技术经理 —-&gt; 前端 —-&gt; 后端 —-&gt; 测试 —-&gt; 运营 。 下面是手写在本子上的笔记，直接用照片形式放在网站上了，大家看着也很好理解。图片如下：]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>组件开发，webAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[目前产品经理的开发最新准则]]></title>
    <url>%2F2017%2F06%2F27%2F%E7%9B%AE%E5%89%8D%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%9A%84%E5%BC%80%E5%8F%91%E6%9C%80%E6%96%B0%E5%87%86%E5%88%99%2F</url>
    <content type="text"><![CDATA[业界统一的开发模式 敏捷开发模式简单点说就是开发产品是一个功能，一个功能的迭代到产品里，而不是产品一出来就把所有功能放进去。通过每扔一个功能到产品里，来看用户的反应。然后根据用户反应做出相应调整与改变。 产品经理的最新使用工具集合 由于云计算的到来，产品经理的工具也发生了很大变化，很多都搬到了云上。 原型制作软件 ： 墨刀 代替了 Axure流程图制作软件 ： ProcessOn 代替了 Visio思维脑图制作软件 ： 百度脑图 代替了 mindjet竞品分析 ： 唯一不变的，用 PPT 做。一个至简的 PTT 非常重要 产品的启动策略 一定不要一开始就做平台型产品，产品一开始的开发尽可能的利用现有平台，先去尝试，如果效果很好，再去做大。 业界PM的标准 热爱 ！同理心抗压能力数据统计和分析能力极客精神 一定要有一颗改变世界的心。Anything is posible]]></content>
      <categories>
        <category>产品经理</category>
      </categories>
      <tags>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA核心技术英语原版阅读完之第一章部分英语单词翻译]]></title>
    <url>%2F2017%2F06%2F27%2FJAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%8B%B1%E8%AF%AD%E5%8E%9F%E7%89%88%E4%B9%8B%E9%83%A8%E5%88%86%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%AF%91%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[学海无涯苦作舟以下单词的出现顺序是按照看书的页面遇到单词的的顺序为标准的applet : 小程序misconception : 误解venture captial : 风险投资solely ：唯一的hype : 炒作overdone : 过头had this to write about Java : 这样写Javairresistible : 不可抗拒的propositon : 主张buzzwords : 流行词portable : 跨平台commentary : 阐释，评注analogy : 比喻 comparable : 可比的one takes this for granted : 一个认为是理所当然的undertaking : 承诺eliminate : 消除chase : 跟踪be intended to : 打算做什么underlying : 底层stretch : 伸展exploratory : 探索just-inn-time compilers : 即时编译器monitor : 监控optimize : 优化at the time : 当时multicore processors : 多核处理器web programming : 网络编程freeze : 冻结in a number of ways : 在许多方面evolving environment : 不断变化的环境at this point : 在此刻hostile code : 敌对代码straightforward : 直接的lure : 诱惑 astonishing : 惊人frustration : 挫折restrictive : 限制dedication : 贡献encounter : 遭遇，遇到exhorting : 劝告describe : 描述implement : 实现distinguish : 区分realistic : 实际derivative : 衍生品]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>英语原版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之散列【也叫哈希】]]></title>
    <url>%2F2017%2F06%2F26%2FJS%E4%B9%8B%E6%95%A3%E5%88%97%2F</url>
    <content type="text"><![CDATA[概念 散列是一种数据存储技术，散列后的数据可以快速地插入或取用。散列使用的数据结构叫做散列表，散列表是基于数组进行设计的。而且数组的长度是预先设定的，可以随时更改。 原则 确保散列表中用来存储数据的数组大小是质数。这是为了防止碰撞。 散列原理 使用散列表存储数据时，通过一个散列函数将键映射为一个数字，这个数字的范围是0到散列表的长度。 散列函数基本性质 如果两个散列值是不相同多的，那么这两个散列值的原始输入也是不相同的。 散列函数的选择 散列函数的选择依赖于键值的数据类型，如果键是整型，最简单的散列函数就是【 键值 % 数组的长度 】，这就是为什么数组的长度必须取质数的原因了，不然会很容易发生碰撞。如果键是字符串类型，需要选取合适的散列函数。 好的散列函数之 霍纳算法 先计算各字符的ASCII码值，在求和时要乘以一个质数。 下面是一个利用霍纳算法的最基本的散列程序，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 使用一个类来表示散列表function HashTable() &#123; // 存放散列数据的数组，也是散列表 this.table = new Array(137); // 散列函数 this.hash = hash; // 显示散列表中的数据 this.show = show; // 将数据存入散列表 this.put = put;&#125;function hash(data) &#123; // 根据实验设置一个质数 const H = 37; var total = 0; // 对各个字符的所有字母对应的ASCII码值进行求和，并且得到的总和乘以一个质数 for (var i = 0; i &lt; data.length; i++) &#123; total += H*total + data.charCodeAt(i); &#125; // 每个单词的所有字母的ASCII码值的总和对散列数组的长度进行取余 total = total % this.table.length; if (total &lt; 0) &#123; total += this.table.length - 1; &#125; return parseInt(total);&#125;function show() &#123; var n = 0; for (var i = 0; i &lt; this.table.length; i++) &#123; // 判断散列数组里下标为i的存储单元里是否有值，有几打印出来 if (this.table[i] != undefined) &#123; console.log(i + ": "+ this.table[i]); &#125; &#125;&#125;function put(data) &#123; // 将需要存储在散列数组里的数据经过散列函数调用，再将调用后的值作为散列数组的下标保存在一个变量里 var pos = this.hash(data); // 然后在其下标【变量的值】对应的存储空间里存储该数据 this.table[pos] = data;&#125;var someNames = ["yangkun","bobo","jack","kangkang"];// 初始化散列表实例var hTable = new HashTable();for (var i = 0; i &lt; someNames.length; i++) &#123; // 将实例中的数据依次存放在散列数组中 hTable.put(someNames[i]);&#125;hTable.show(); 输出如下图所示 散列表的应用 错误校正【也叫沉余校验】，语音识别，Rabin-Karp字符串搜索算法【平均搜索时间是O(n),这个算法是创建在使用散列来比较字符串的基础上的】，加密【通过散列函数加密】其中语音识别用到了散列函数 MD5 总结 效率特别高，在散列表上插入、删除和取用数据都非常快。但是对于查找操作来说却效率低下，不过查找可以用二叉查找树实现。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react第二节之高质量组件]]></title>
    <url>%2F2017%2F06%2F25%2Freact%E7%AC%AC%E4%BA%8C%E8%8A%82%E4%B9%8B%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[学海无涯苦作舟 组件的命名格式 首字母大写，后面每个单词的首字也大写。 组件划分的原则高内聚 把逻辑紧密相关的内容放在一个组件中。 低耦合 不同组件之间的依赖关系要尽量弱化，也就是每个组件要尽量独立。 组件的数据种类 分为两种：prop 和 state 如何选择 prop是组件的对外接口，state是组件的内部状态。对外用prop，对内用state。 prop 【property】 prop支持的类型非常多，可以是任何一种JavaScript语言支持的数据类型。注意：当prop的类型不是字符串时，在JSX中必须用花括号 {} 把prop值包住。 比如下面代码123&lt;Appstyle = &#123;&#123;color: "red"&#125;&#125;/&gt; 外层花括号代表是JSX的语法，内层的花括号代表这是一个对象常量。 注意事项 一旦prop传入组件后，就不能被修改了。如果需要记录自身数据变化，就必须使用state了。为什么？因为React组件扮演的是render函数的角色，必须是一个没有副作用的纯函数。而修改prop的值，是一个副作用，所以要避免修改。 state 大致步骤：初始化state –&gt; 读取state –&gt; 更新state注意：组件的state必须是一个JavaScript对象,哪怕只是一个数字类型的数据，也只能把它存作state某个字段对应的值。 组件的生命周期装载过程依次调用的函数有： constructor ES6中每个类的构造函数。无状态的组件可以不需要定义构造函数，一个React组件需要构造函数，主要是为了这些目的：初始化state；绑定成员函数的this环境。 getInitialState 这个函数的返回值是用来初始化组件的this.state getDefaultProps 这个函数的返回值作为props的初始值。 注意：getInitialState和getDefaultProps这两个方法在ES6的方法定义的React组件中根本用不到，在ES6中，可以构造函数中通过给this.state赋值完成状态的初始化，通过给类属性defaultProps赋值指定props初始值。 componentWillMount 一般不定义这个函数，因为这个时候没有任何渲染出来的结果，即使调用this.setState修改状态也不会引发重新绘制。这个函数存在的目的主要是为了和componentDidMount对称。注意：既可以在服务器端被调用，也可以在浏览器端被调用。 render 是React组件中最重要的函数，任何一个组件都必须要实现render函数，因为React组件的父类React.Component类对render函数没有默认实现，而其他周期函数都有默认实现。注意：render函数并不做实际的渲染动作，它只是返回一个JSX表示的对象，最终由React来操作渲染过程。有些特殊组件的作用不是渲染界面，那就让render函数返回一个null或者false，这就等于告诉React，这个组件这次不需要渲染任何DOM元素。牢记：React要求render函数只能返回一个元素，如果有多个组件需要render，则需要将这些子组件实例用div包起来。 componentDidMount 当所有组件的render函数都调用后，通过React库把所有组件返回的结果综合起来，知道如何产生对应的DOM修改，这个时候，才会依次调用各个组件的componentDidMount函数作为装载过程的收尾。注意：componentDidMount只在浏览器端执行，因为”装载“是一个创建组件并放到DOM树上的过程，所以是不可能在服务器端完成的，浏览器端渲染不会产生DOM树。componentDidMount被调用的时候，组件已经被装载到DOM树上了。 更新过程 依次调用的函数有：componentWillReceivePropsshouldComponentUpdatecomponentWillUpdaterendercomponentDidUpdate更新过程就不细致说了，感觉没什么好讲的。 卸载过程只调用一个函数： componentWillUnmount 如果在componentDidMount中用非React的方法创造了一些DOM元素而不去处理它，那么就很可能会造成内存泄露，这个就需要在componentWillUnmount中把这些创造的DOM元素清理掉。 总结心得 React的学习曲线还是挺陡峭的，组件涉及到的知识有很多，不过这是基础，要认真去解决组件的每个细节，这样才能为你后面学习React的其他高级知识打下坚实的基础。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之贪心算法]]></title>
    <url>%2F2017%2F06%2F24%2FJS%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概念贪心法就是遵循某种规则，不断贪心地选取当前最优策略的算法设计方法。贪心算法总是会选择当下的最优解，而不去考虑这一次的选择会不会对未来的选择造成影响。 使用贪心算法的思路 使用贪心算法通常表明，实现者希望做出的这一系列局部“最优”选择能够带来最终的整体“最优”选择。如果是这样的话，该算法将会产生一个最优解，否则，则会得到一个次优解。对于很多问题来说，寻找最优解很麻烦，这么做不值得，所以使用贪心算法就足够了。 代码如下 下面用找零做例子 有1元、5元、10元、25元的整钞，先用这些整钞支付66元，最少需要多少张整钞？ 123456789101112131415161718192021222324252627282930313233343536373839404142function makeChange(origAmt, coins) &#123; // 初始化表示剩下的余额，开始设置为0 var remainAmt = 0; if (origAmt % 25 &lt; origAmt) &#123; coins[3] = parseInt(origAmt / 25) remainAmt = origAmt % 25; origAmt = remainAmt; &#125; if (origAmt % 10 &lt; origAmt) &#123; coins[2] = parseInt(origAmt / 10) remainAmt = origAmt % 10; origAmt = remainAmt; &#125; if (origAmt % 5 &lt; origAmt) &#123; coins[1] = parseInt(origAmt / 5) remainAmt = origAmt % 5; origAmt = remainAmt; &#125; coins[0] = parseInt(origAmt / 1);&#125;function showChang(coins) &#123; if(coins[3] &gt;0 )&#123; console.log("该硬币的数量是："+coins[3]+" "+"总面值为："+ coins[3]*25); &#125; if(coins[2] &gt;0 )&#123; console.log("该硬币的数量是："+coins[2]+" "+"总面值为："+ coins[2]*10); &#125; if(coins[1] &gt;0 )&#123; console.log("该硬币的数量是："+coins[1]+" "+"总面值为："+ coins[1]*5); &#125; if(coins[0] &gt;0 )&#123; console.log("该硬币的数量是："+coins[0]+" "+"总面值为："+ coins[0]*1); &#125; &#125;var origAmt = 66;var coins = [];makeChange(origAmt, coins);showChang(coins); 输出如下 心得体会贪心算法很好理解，很经典，掌握其核心：只关注当下的最优解 深刻理解就可以很好的运用贪心算法了。]]></content>
      <categories>
        <category>JS世界里的算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime3的经典操作和快捷键]]></title>
    <url>%2F2017%2F06%2F24%2Fsublime3%E7%9A%84%E7%BB%8F%E5%85%B8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器 以下都是在window操作系统下的快捷键【穷，买不起Mac 囧】 最爽的快捷键 可以进行多行选择以及对选择的多行内容进行同时编辑 操作： 把鼠标放到你想要选取的内容上，不必刻意进行全选，只要光标在所选内容上就可以了，然后按 Ctrl + D 那么光标所在的内容将会全部被选中，并且其他的内容会被标记为待选中状态。这个时候再次点击 D 那么下面的第一个带选中的将会被选中。后面再次点击 D 则下面依次被选中。如果选中的不是你想要的，需要跳过某一个内容，继续选择后面的未选中的内容。则需要进行如下操作，Ctrl + D 选中不想要的内容后，按 Ctrl + K 撤销选中，此时你会看到内容还是选中的，没事，这时你按 Ctrl + D 就会看到不想要的内容已经是未选中，并且已经选中了撤销的内容的下面一个待选中的内容了 还有一种可以实现上面的操作： 按住 Shift 然后 按住鼠标右键，进行上下拖动。这个不好说明，只要你按住这两个键，然后试了几下，你就自然知道怎么实现的了。 对于上面两种操作，我的心得体会是： 如果是有内容的，比如你已经写好了三个 if 语句，然后选中三个，那么你可以使用第一种操作。如果是没有内容的，你想在空白处写三个 if 语句，你可以使用第二种操作。 用好这个快捷键，可以极大的提高写代码的效率。 最人性化的保存方式 用其他编辑器，要想使用某一个类型的文件，需要点击保存，然后弹出命名文件和类型的窗口。用sublime3就可以很完美的使用 Ctrl + n 新建文件，不需要点击保存来选择文件类型，新建后文件格式默认是 text 格式，你可以在界面的右下角看到 Plain Text 字样。这时候按住快捷键 Ctrl + Shift + P 后，会弹出一个对话框，此时输入相应的文件名后缀，就会出现对应的格式选项，选择后，按回车键即可发现文件已经是你想要的格式类型了，后面就可以随心所欲的使用对应文件类型的语法提示了。 最完美的扩展插件机制这个就不说了，插件安装可以网上搜一下。我个人觉得上面两个内容是我最喜欢sublime的原因。]]></content>
      <categories>
        <category>编辑器和工具使用</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之动态规划]]></title>
    <url>%2F2017%2F06%2F23%2FJS%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[概念动态规划方案通常会用一个数组来建立一张表，用于存放被分解众多子问题的解。当算法执行完毕，最终的解将会在这个表中很明显的地方找到。 动态规划与递归的联系联系：动态规划有时被认为是一种与递归相反的技术。递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整个问题。动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个整体方案，从而解决掉整个大问题。 使用思路 使用动态规划设计的算法应该从它能解决的最简单的子问题开始，继而通过得到的解，去解决其他更复杂的子问题，直到整个问题都被解决。所有子问题的解通常被存储在一个数组里以便于访问。 代码如下 用斐波那契数列做例子。1234567891011121314151617181920212223242526272829303132333435function dynFib(n) &#123; // 定义val数组来保存中间结果 var val = [] for (var i = 0; i &lt;= n; i++) &#123; val[i] = 0; &#125; // 如果斐波那契数是1或者2，则返回1 if (n==1 || n==2) &#123; return 1; &#125; // 否则，把数值1和2保存在val数组中1和2的位置 else&#123; val[1] = 1; val[2] = 2; // 从3开始，将数组中的每个元素赋值为前两个元素只和，直到循环结束 for (var i = 3; i &lt;= n ; i++) &#123; val[i] = val[i-1] + val[i-2]; &#125; // 返回数组的最后一个元素即为最终计算的斐波那契数值 return val[n-1]; &#125;&#125;var start = new Date().getTime();console.log(dynFib(30));var stop = new Date().getTime();var result = stop - start;console.log("用时为： "+result+"毫秒"); 输出如下 心得体会更深刻的理解了递归的效率为什么很低，就是因为有太多值在递归调用中被重新计算。下面一张图就可以说明它的工作效率为什么这么差。上图是斐波那契函数生成的递归树，从图中就可以看出重复计算了很多值。 如果编译器可以将已经计算的值记录下来，函数的执行效率就不会很差。动态规划就是用一个数组来存储已经计算过的值，以此来提高效率。]]></content>
      <categories>
        <category>JS世界里的算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS算法之二分查找算法]]></title>
    <url>%2F2017%2F06%2F23%2FJS%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[概念字面意识上就是 使用前提数据要是有序的，对无序的数据无效。 步骤1：将数组的第一个元素的位置设置为下边界【0】2：将数组的最后一个元素的位置设置为上边界【数组的长度减1】3：若下边界等于或小于上边界，则作如下操作。 a. 将中点设置为【上边界加下边界】除以2. b. 如果中点的元素小于查询的值，则将下边界设置为中点元素所在下标加1。 c. 如果中点的元素大于查询的值，则将上边界设置为中点元素所在下标减1。 d. 否则中点元素即为要查找的数据，可以进行返回。 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function binSearch(arr, data) &#123; // 上界 var upperBound = arr.length-1; // 下界 var lowerBound = 0; while (lowerBound &lt; upperBound) &#123; // 取中值 var mid = Math.floor((lowerBound+upperBound)/2); // 改变上界或者下界的值 if(arr[mid] &lt; data)&#123; lowerBound = mid + 1; &#125;else if(arr[mid] &gt; data)&#123; upperBound = mid - 1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125;var nums = [];for (let i = 0; i &lt; 100; i++) &#123; // 0到100的整数 nums[i] = Math.floor(Math.random()*100);&#125;// 对数组排序var sortNums = nums.sort();// 不换行打印排序后的数组console.log(sortNums+" ");// 设置需要找的数据var val = 38;// 调用二分查找函数var retval = binSearch(sortNums,val);// 判断是否存在，存在的话将位置打印出来if (retval &gt; 0) &#123; console.log("已经找到"+val+"所在位置为：" + retval);&#125; else &#123; console.log(val + "没有出现在这个数组中");&#125; 输出如下 心得体会 对于二分查找法需要有序数据的这个前提条件感到不太满意，无形中是效率变低。不过相对于顺序查找，在处理大数据集时，速度要明显快。因为决定算法性能的每一步循环嵌套中，二分查找减少了一半的查找量（数组中的元素）。]]></content>
      <categories>
        <category>JS世界里的算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react第一节之必知概念]]></title>
    <url>%2F2017%2F06%2F22%2Freact%E7%AC%AC%E4%B8%80%E8%8A%82%E4%B9%8B%E5%BF%85%E7%9F%A5%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[命名由来 React践行的是“响应式编程”思想，也就是 Reactive Programing React 的核心思想通过组件来开发应用。 组件所谓组件，指的是能完成某个特定功能的独立的、重用的代码。 基于组件的应用开发是广泛使用的软件开发模式。 JSX全称：JavaScript eXtension目的：让我们可以在JS中编写像HTML一样的代码。一种JavaScript的数据结构，不是真正的HTML，也和DOM没有关系，其实就是React.createElement写法的语法糖，是快速高效书写这个函数的方法，它返回的是ReactElement。 JSX不能直接在浏览器中使用，需要转义成标准的JS语法，而JS编译器Babel就是目前最好的JSX的转义工具。 Babel是什么：一个JavaScript编译器。作用：一个是让代码支持ES6的语法，一个是支持React的一些特性（例如JSX语法）。 Virtual DOM 【虚拟DOM】目的：尽量减少DOM操作每个React组件都是用虚拟DOM渲染的。 DOM树是对HTML的抽象，那Virtual DOM就是对DOM树的抽象。组件的DOM结构映射到虚拟DOM上，当需要重新渲染组件时，React在虚拟DOM上实现了一个 Diff 算法，通过这个算法寻找需要变更的节点，再把里面的修改更新到实际需要修改的DOM节点上，这样就避免了整个渲染DOM带来的巨大成本。 ##]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法中的常见的单词【一直更新】]]></title>
    <url>%2F2017%2F06%2F22%2F%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[upperBound : 上边界lowerBound : 下边界tonken : 在词法分析中是标记的意识capacity : 容量]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS英语单词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《暗时间》读书笔记]]></title>
    <url>%2F2017%2F06%2F21%2F%E6%9A%97%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[波普尔曾经说过：人生不过是解决问题。 挑几个重要的收获说吧： 你比别人往后多看一年，你就比别人领先一年的时间来准备。 思考问题，去追寻答案的时候，一定要学会联想。 一定不要把简单的事情搞复杂。 遇到问题一定要自己动手，不要直接问答案。 坚持写博客，记录笔记，与自己对话。 找到你的不可替代性和核心竞争力。 兴趣遍地都是，专注和持之以恒才是真正稀缺的。 过早退出是一切失败的根源。 生活中的选择远比我们想象的要多，细微的选择差异造就了不同的人生。 一生的知识积累，自学的起码占90%]]></content>
      <categories>
        <category>能力提升</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法的本质]]></title>
    <url>%2F2017%2F06%2F20%2F%E7%AE%97%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[本质算法本质上可以看做是在一个解空间当中的搜索问题，所以要分析一个算法的好坏，首先要弄清它的解空间的结构，然后分析它是怎么来探索这个解空间的。 如何弄清解空间 举个例子，例如排序算法，其解空间可以看做是所有可能的下标排列组合，其中有且仅有一个排列是正确的排序排列，这里假设元素各不相同，那么一个算法在探索这个解空间方面的行为就决定了它的效率高低，最简单的，如果一个算法每次都只能检查解空间中的一个点，那么这个算法的复杂度就是解空间的大小。 对排序算法而言也就是 n! 。从这个角度来看，我们很容易地发现，所有基于比较的排序算法，其复杂度为什么是以O(nlogn)为下界的，因为一次比较操作最多有两个结果，a&gt;b或b&gt;a，既然只有两种结果，那么最多只能将空间进行二分，如果每次都能完美地二分，那么找到那个唯一点最终需要的步骤就是log(n!) = O(nlogn)。这样就不难理解为什么基于比较的排序算法的复杂度最好不过如此了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习react遇到的英文单词【一直更新】]]></title>
    <url>%2F2017%2F06%2F18%2FJS%E4%B8%AD%E7%BA%A6%E5%AE%9A%E4%BF%97%E6%88%90%E7%9A%84%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%9A%84%E6%84%8F%E8%AF%86%2F</url>
    <content type="text"><![CDATA[eject：弹射delegation：委托bable：嘈杂声loader：处理机，装货机dispatcher：调度者emit：发出，广播react：反应Redux: reducer + fluxparse : 解析stringify : 字符串化]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS英语单词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包和定时器的终极面试题]]></title>
    <url>%2F2017%2F06%2F12%2F%E9%97%AD%E5%8C%85%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E7%BB%88%E6%9E%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最基础的问题123for (var i = 0; i &lt; 3; i++) &#123; console.log(i);&#125; 输出如下 这个很好理解的，没有任何异步操作，按部就班的一次显示0 1 2 升级一层能力12345for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;,1000)&#125; 输出如下 我是将这段代码直接写在控制台上，于是先输出了一个随机数字，然后等待了一秒后立即输出了 3 3 3 ,如果将代码嵌入到HTML页面中，则不会有随机数字出现，其他结果都一样。将这段代码在控制台上再输出几次，发现随机数字依次加3。 为了更好理解，加个时间戳来更好的显示时间差，可以这样写1234567for (var i = 0; i &lt; 3; i++) &#123;console.log(new Date()); setTimeout(function () &#123; console.log(i); console.log(new Date()); &#125;,1000)&#125; 输出如下 很明显，先调用for循环立即连续输出三个时间，然后一秒以后三个定时器同时输出。 再次升级12345for (let i = 0; i &lt; 3; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;,1000)&#125; 12345678for (var i = 0; i &lt; 3; i++) &#123; (function (i) &#123; setTimeout(function() &#123; console.log(i); &#125;,1000) &#125;)(i);&#125; 上面两个代码依次输出如下 对于第一个for函数，可以这样写12345678for (let i = 0; i &lt; 3; i++) &#123; var a = new Date(); setTimeout(function() &#123; console.log(i); var now = new Date(); console.log(now - a); &#125;,1000)&#125; 输出如下 从输出结果看，块级作用域，将i限制在块级作用域中，也就是不会被覆盖，为什么不会覆盖，因为浏览器会把块级作用域内的变量值另存起来，这点很重要。执行过程还是一样，一秒钟后立即输出1 2 3 终极进阶1234567891011for(var i = 0; i &lt; 3; i++) &#123; setTimeout( (function(i) &#123; return function() &#123; console.log(i); &#125; &#125;)(i), (function(i) &#123; return i * 1000; &#125;)(i) );&#125; 输出如下 上面的代码加个时间戳可以改成这样12345678910111213for(var i = 0; i &lt; 3; i++) &#123; var a = new Date(); setTimeout( (function(i) &#123; return function() &#123; var now = new Date(); console.log(i, now - a); &#125; &#125;)(i), (function(i) &#123; return i * 1000; &#125;)(i) );&#125; 输出如下 这是最终极的写法了，这样更好的表示了其中时间的过程。三个定时器是同时计时的，第二个计时器是2s，也就是在第一个定时器等待1s输出后，第二个定时器在1s后就会输出。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>closure</tag>
        <tag>setTimeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产品经理之过滤法则]]></title>
    <url>%2F2017%2F06%2F10%2F%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%B9%8B%E8%BF%87%E6%BB%A4%E6%B3%95%E5%88%99%2F</url>
    <content type="text"><![CDATA[序：有时候智商够了，事情就没有必要说那么清楚了 直接取精华一个好的0怎样产生？这里有8问可以给你灵感。 这个概念的原始出处是哪里，全球最佳实践在哪里？ 这个概念能为它的目标用户带来什么？ 进入的壁垒是否过高或过低？ 那些用户会从中受益，他们是男是女，年龄多大，用户多少？ 这个概念是否有商业模式？ 是否可以成为平台或现金牛，在公司战略布局中处于什么位置？ 名词解释： 平台产品是什么？ 通过自身的优势拉动其他产品的产品，这是公司的基石。衡量一款产品的平台性质时，它的用户数是最关键核心的指标。 现金牛产品是什么？ 利润率超高的产品，并且利润占据公司总利润的比例很大。]]></content>
      <categories>
        <category>0到1</category>
      </categories>
      <tags>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之快速排序]]></title>
    <url>%2F2017%2F05%2F19%2F%E7%AE%97%E6%B3%95%E7%95%8C%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[概念一种分而治之的算法，通过递归的方式依次分解为包含较小元素和较大元素的不同子序列。然后不断重复这个步骤直到所有数据都是有序的。 时间复杂度平均时间复杂度为O(nlogn) 算法步骤1：选择一个基准元素，将列表分隔成两个子序列；2：对列表进行重新排序，将所有小于基准值的元素放在基准值的前面，所有大于基准值的元素放在基准值的后面；3：分别对较小元素的子序列和较大元素的子序列重复步骤1和2。 代码如下 123456789101112131415161718192021222324252627282930313233function qSort(list) &#123; if (list.length==0) &#123; return []; &#125; //定义一个基准值 var pivot = list[0]; //用于放小于基准值的元素的数组 var lesser = []; //用于放大于基准值的元素的数组 var greater = []; for (let i = 1 ; i &lt; list.length; i++) &#123; if (list[i]&lt;pivot) &#123; lesser.push(list[i]); &#125; else &#123; greater.push(list[i]); &#125; &#125; //使用了递归,将lesser数组、基准值pivot和greater数组依次连接起来构成新的数组 return qSort(lesser).concat(pivot,qSort(greater));&#125;var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = Math.floor((Math.random()*10)+1);&#125;console.log(a);console.log(qSort(a)); 输出如下 心得根据我的测试，快速排序算法非常适用于大型数据集合，可是在处理小数据集合时性能反而会下降。]]></content>
      <categories>
        <category>JS世界里的算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Axure写产品需求文档]]></title>
    <url>%2F2017%2F05%2F11%2F%E7%94%A8Axure%E5%86%99%E4%BA%A7%E5%93%81%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[链接如下： http://www.jianshu.com/p/2006f660d2b0]]></content>
      <categories>
        <category>Axure</category>
      </categories>
      <tags>
        <tag>Axure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端进阶文章目录]]></title>
    <url>%2F2017%2F05%2F11%2F%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[很棒的文章，看完进阶没有问题。前端基础进阶（一）：内存空间详细图解http://www.jianshu.com/p/996671d4dcc4 前端基础进阶（二）：执行上下文详细图解http://www.jianshu.com/p/a6d37c77e8db 前端基础进阶（三）：变量对象详解http://www.jianshu.com/p/330b1505e41d 前端基础进阶（四）：详细图解作用域链与闭包http://www.jianshu.com/p/21a16d44f150 前端基础进阶（五）：全方位解读thishttp://www.jianshu.com/p/d647aa6d1ae6 前端基础进阶（六）：在chrome开发者工具中观察函数调用栈、作用域链与闭包http://www.jianshu.com/p/73122bb3d262 前端基础进阶（七）：函数与函数式编程http://www.jianshu.com/p/69dede6f7e5f 前端基础进阶（八）：深入详解函数的柯里化http://www.jianshu.com/p/5e1899fe7d6b 前端基础进阶（九）：详解面向对象、构造函数、原型与原型链http://www.jianshu.com/p/15ac7393bc1f 前端基础进阶（十）：面向对象实战之封装拖拽对象http://www.jianshu.com/p/b3dee0e84454 前端基础进阶（十一）：详细图解jQuery对象，以及如何扩展jQuery插件http://www.jianshu.com/p/3f97570d22b4 前端基础进阶（十二）：深入核心，详解事件循环机制http://www.jianshu.com/p/12b9f73c5a4f 前端基础进阶（十三）：Promise使用详解http://www.jianshu.com/p/fe5f173276bd 前端基础进阶（十四）：ES6基础知识合集http://www.jianshu.com/p/cfb0893c34f1 前端基础进阶（十五）：详解 ES6 Moduleshttp://www.jianshu.com/p/3f97570d22b4 我想这将是最有价值的react入门与进阶教程http://www.jianshu.com/p/83bda9cd8c67]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>react</tag>
        <tag>ES6</tag>
        <tag>this</tag>
        <tag>Promise</tag>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之冒泡排序]]></title>
    <url>%2F2017%2F05%2F10%2FJS%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序 通俗的说就是把一堆数放进有序数组里，然后从第一个数开始，依次比较自己和后一个数的值，如果需要输出升序排列，那就要把大的数放在后面，于是很自然的想到如果自己比后一个数大，那就要互相交换值，如果不大，则不需要交换。依次往后循环即可完成升序排序。降序排列同理。 算法步骤1：比较相邻的元素。如果第一个比第二个大，就互相交换。 2：对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。做完后，最后的元素会将是最大的数。 3：针对所有的元素重复以上的步骤，除了最后一个。 JS代码如下：123456789101112131415function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; console.log(arr);&#125;bubbleSort([5,4,3,2,1]); 将上面程序保存名为 bubbleSort 的 js 文件，然后进入 bubbleSort 所在的目录下，用 node bubbleSort.js 命令运行程序，结果如下图。 算法性能分析 由于嵌套两层 for 循环，导致时间复杂度为 O(n2)，n2 是 n 的平方的意识。当 n 很大的时候，性能非常差。所以仅仅只适合 n 很小的情况。]]></content>
      <categories>
        <category>JS世界里的算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底征服闭包定义、特点、价值、用法]]></title>
    <url>%2F2017%2F04%2F10%2F2017-04-10-%E5%BD%BB%E5%BA%95%E5%BE%81%E6%9C%8D%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包的定义与含义 闭：是指闭包的内部环境对外部不可见。 闭包具有控制外部域的能力，也就是可以访问外部环境的执行域，，同时又能防止外部域对闭包的反向控制，也就是说，闭包的领域是对外封闭的。 闭包的实现方法 JS闭包是通过function实现的 闭包的特权 闭包内声明的变量，闭包外的任何环境都无法访问。举个栗子：12345678910function f1()&#123; var a=10; var b=20; function f2()&#123; console.log(a); &#125;; return f2;&#125;var result =f1();result(); 这里的闭包是f1函数，不懂没关系，下面我会运用这个例子上面写的知识来去解释为什么f1是闭包。 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的，但是反过来就不行，f2内部的局部变量对f1就是不可见的。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们就可以在f1外部读取它的内部变量！这种函数叫称之为闭包函数。所以，这个困扰初学者到底哪个是闭包的问题也就解决了，顺着这个思路你就会发现变量a和变量b也是闭包的一部分，因为他们对外不可见。所以这个代码例子的闭包部分是123var a=10; var b=20;function f2()&#123;&#125;; JS垃圾回收机制这里为了让小伙伴们更好的理解闭包，我顺带把JS垃圾回收机制说一下，尽量用通俗简单的话语解释。一句话定义：JS垃圾回收机制规定：当你调用完一个函数后，他就不存在了 举个栗子：1234function aaa() &#123; var a =1; &#125;aaa(); 上面这段代码当函数aaa调用完【aaa();这句就是指函数调用】，那么变量a也就不存在了，它所占的内存就被JS垃圾回收机制给回收了。 那么怎样才能不能JS垃圾回收机制回收呢？也就是让变量a在内存中呆的时间久一点，别一执行完函数就消失了。 解决这个问题就是要运用闭包的特性。 闭包的特点函数嵌套函数内部函数可以引用外部函数的参数和变量,这样就会使参数和变量不会被垃圾回收机制所收回 举个栗子：1234567function f3(a)&#123; var b=1; function f4()&#123; alert(a); alert(b); &#125; &#125; 上面栗子可以看出，函数f4内部引用了外部函数f3的参数a和局部变量b这样函数执行完以后，参数和变量都不会被垃圾回收机制回收。 下面再看一个栗子【首先说明，下面这个栗子很明显不是闭包】1234567function aaa()&#123; var a =1; a++; console.log(a); &#125;aaa();aaa(); 上面代码的执行结果如图： 调用两次的结果都是2，变量a并没进行累加，说明在调用第一次函数aaa后，变量a【值为2】已经销毁了，第二次调用后，变量a又会重新从1加到2进行输出。1234567var b =1;function bbb()&#123; b++; console.log(a); &#125;bbb();bbb(); 调用两次的结果:第一次是2，第二次是3，为什么呢，因为变量b是全局变量，是定义在全局作用域下的【简单点解释就是全局变量，做大的一个作用域】当函数bbb执行完后，虽然函数bbb里的东西销毁了，但是在全局作用域中，变量b还存在，就导致了变量b没有被销毁，继续存在，于是就会一直累加。从这里再次对比上一个栗子，变量a是局部变量，也没有在外部域存在，所以执行完函数aaa后，就会被销毁。 那么如何才能既让a是局部变量，又能让a累加呢？ 这就是闭包最拿手的事情!! 栗子如下： 1234567891011function aaa() &#123; var a = 1; return function() &#123; a++; console.log(a); &#125; &#125; var c = aaa(); c(); c(); alert(a); 执行完以后显示如图：第一次调用结果为2，第二次调用结果为3，成功实现了既让a是局部变量，又能让a累加的功能。同时你看到了上面，变量a未定义，对，你没有看错，我在全局作用域中了加了一句alert(a)，结果表明外部域是无法访问到内部域的变量a的。现在是不是有点慢慢通窍了，有种茅塞顿开的感觉了吧。 最后用一句话定义闭包：函数内在包含子函数，并最终return子函数。 12345678910function f1()&#123; var a=10; var b=20; function f2()&#123; console.log(a); &#125;; return f2;&#125;var result =f1();result(); 闭包函数的最大价值在于：我们可以在函数(f2)的外部（即子函数也就是f2函数），直接读取该函数的局部变量。 再深入研究，就会发现f1()函数就如同一个“类”，而其定义的局部变量就如同该“类”的全局变量；而子函数f2()函数，则如同这个“类”的方法，可以直接使用这个“类”的全局变量n 闭包到底有什么用？1、缓存：显而易见，就是可以实现数据缓存，我们可以把一个需要长期用到的变量设为闭包函数的局部变量，在子函数里面直接使用它。因此局部变量只定义初始化一次，但我们可以多次调用子函数并使用该变量。这比起我们在子函数中定义初始化变量，多次调用则多次初始化的做法，效率更高。闭包函数常见的一种用途就是，我们可以通过此实现计数功能。在闭包函数定义一个计数变量，而在子函数中对其进行++的操作。这样每次调用闭包函数，计数变量就会加1。 2、实现封装：如前面所说，闭包函数就如同一个“类”，只有在该闭包函数里的方法才可以使用其局部变量，闭包函数之外的方法是不能读取其局部变量的。这就实现了面向对象的封装性，更安全更可靠。 闭包的知识我先说到这里，虽然有一些很重要的细节我没有说，比如，怎么改进这个闭包的书写形式来达到更好的模块化，其实是关于函数的知识，我不想在闭包上把很多细节都扯了，这篇文章对于你理解闭包已经没有问题了，毕竟在这个碎片化时间的世界里，一篇文章不能太长，这里其他的知识我先不说了，过几天我写一篇征服JS函数的文章，再结合这个把闭包彻底搞透。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产品经理之消灭拖延]]></title>
    <url>%2F2017%2F03%2F15%2F%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%B9%8B%E6%B6%88%E7%81%AD%E6%8B%96%E5%BB%B6%2F</url>
    <content type="text"><![CDATA[推荐一篇文章，很不错http://www.woshipm.com/zhichang/261080.html]]></content>
      <categories>
        <category>产品经理</category>
      </categories>
      <tags>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运营人的矛与盾]]></title>
    <url>%2F2017%2F03%2F10%2F%E8%BF%90%E8%90%A5%2F</url>
    <content type="text"><![CDATA[为什么运营人即是矛又是盾往本质上看，运营人的存在是为了去最大化实现公司的业务价值，去为公司盈利，去让公司的产品更好的被更多的人知道和使用。 那么对于运营人自身的矛盾也就很好理解了。 比如举个很好的例子： 公司的考研培训部门让你去给该部门做运营，作为运营人，会去向广大大学生宣传当今每年毕业人数几百万，就业压力很大，如果去考研，既能提高自己的知识与学历，又能更容易的找到自己满意的工作。 然后获得非常好的效果后，你被该公司安排到就业培训部门救火，这时候作为运营人，你就要展示矛与盾的能力了，这时候，你就要开始向大学生宣传读个研还是要找工作，出来比起人家的三年工作经验，没有多大优势。这个例子就很好的体现出了运营人的矛盾，或者有种说法叫运营人的阴谋论，当然这不是贬低运营人，知识客观分析，这也展现了一个好的运营人所需要具有的能力。 如何写一个好的文案：一个重要技巧：写失去的东西能够获得更高的关注度，这也是一个好的标题要多借鉴的方面 写作思路：一个好的标题，要多去想目标用户为什么要看这篇文章，看这篇文章的目的是什么，看这篇文章的用户的痛点是什么？ 把这个目的和痛点结合写成标题，这样基本就是一个好的标题的文案。]]></content>
      <categories>
        <category>运营</category>
      </categories>
      <tags>
        <tag>运营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX的日常使用方法]]></title>
    <url>%2F2016%2F12%2F27%2FAJAX%E7%9A%84%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[翻译 Asynchronous JavaScript XML 定义 无需刷新页面就能从服务器获得数据的一种方法。 思路 使用XHR对象取得新数据，再通过DOM将新数据 插入到页面中。 具体步骤第一步检测原生XHR对象是否存在 第二步1var xhr = createXHR(); 第三步1xhr.open("get","example.php",true); 调用open()方法，不会真正发送请求，只是启动一个请求以备发送。注意：参数 true 是异步请求方式，对应的 false 是同步请求，用AJAX的目的就是为了异步请求，所以我们基本都是用 true 做参数 get方式：把数据放到网址url()里提交 —-&gt; 安全性很低 —-&gt; 容量很低，只有几K，几M 。post方式：把数据放到 html:content 里提交 —-&gt; 安全性一般 —-&gt; 容量很高，几乎无限。get主要用来获取，会缓存，便于分享，也就是把网址复制给别人。post主要用来提交上传数据，不会缓存。 第四步1xhr.send(); 发送特定的请求，发送以后，请求就会被分配到服务器。 结果 服务器收到请求后会发出一个响应给XHR对象，然后自动填充xhr的属性。填充xhr的属性主要有: responseTest responseXML status statusText 下面是 AJAX 异步请求代码 1234567891011121314var xhr = createXHR();xhr.onreadystatechange = function() &#123; if (xhr.readystate == 4) &#123; if (xhr.status &gt;= 200&amp;&amp;xhr.status &lt; 300 || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful:"+ xhr.status); &#125; &#125;&#125;xhr.open("get","example.php",true);xhr.send(); AJAX扩展可以自定义请求头部信息：1setRequestHeader(); 上面这个方法要放在xhr.open()和xhr.send()之间。用下面方法可以取得所有头部信息1xhr.getAllRequsetHeaders();]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站性能优化总结]]></title>
    <url>%2F2016%2F12%2F20%2F%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[追求极致性能的原则第一点：减少Http请求次数。第二点：减少DOM操作次数。第三点： 少用全局变量，缓存DOM节点查找的结果，减少IO读取操作。第四点： 图片预加载。第五点： 避免使用动态属性，比如CSS表达式。第六点： 使用雪碧图技术。第七点： CSS压缩，JS压缩技术。第八点： 对于不经常更新的数据使用浏览器缓存。第九点： 使用CDN内容分发技术。]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>WEB性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解开Return的奥秘]]></title>
    <url>%2F2016%2F12%2F15%2F%E8%A7%A3%E5%BC%80Return%E7%9A%84%E5%A5%A5%E7%A7%98%2F</url>
    <content type="text"><![CDATA[苦恼 每次写JS代码的时候总是会遇到各种return语句，很头疼。最近整理了return的各种隐蔽的知识，写下总结分析出来。 举个例子1return false; 上面一句代码到底有几层含义第一层含义：只是对当前函数有效，并不会影响其他函数的执行。第二层含义：阻止默认事件行为。 比较下面两段代码12345function call() &#123; var b = 2+3; return b;&#125;console.log(call()); 输出入下：call函数用return语句返回一个表达式结果，然后调用call函数打印结果值。 1234function call() &#123; var b = 2+3;&#125;console.log(call()); 输出入下：call函数没有写return语句来返回一个值，那么这个call函数返回的结果是undefined，所以打印call函数调用的结果是undefined。 总结： return 后面的语句不会再执行【仅限return所在的函数中】如果函数有一个结果，然后调用这个函数，则需要在函数中return来保存函数结果。]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>return</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP开发流程简要分析]]></title>
    <url>%2F2016%2F11%2F24%2FAPP%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[开发流程一个完整的软件开发，分为网页端和移动端(APP) 移动端又分为 Android 端和 IOS 端 使用的开发模式是移动应用开发常用的 MVC 模式 【Model + View + Controller】 服务器端开发流程服务器框架搭建 Spring MVCSpting 是一个分层的 Java SE/EE full-stack（一站式） 轻量级开源框架。 数据库设计和部署 MySQL 服务器端代码编写 Java 客户端开发流程 基本框架搭建—-&gt; 界面及素材设计—-&gt; 页面跳转设计—-&gt; 模块类的设计—-&gt; 模块类的实现。]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>步骤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写好一个竞品分析]]></title>
    <url>%2F2016%2F10%2F10%2F%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[产品概况产品简介用一个表格就可以搞定 产品名称 上线时间（web） 当前版本 迭代版本 体验环境 slogan（标语） 竞品A 竞品B 竞品C 下载量同样一个表格 产品名称 Android下载量 IOS下载量 Android近7日日均下载 IOS近7日日均下载量 竞品A 竞品B 竞品C 需求图谱搜索指数概况和趋势用表格把指数概况表示出来，再用一个表格把指数趋势表示出来。 市场分析市场规模用表格，比如直方图配合折线图来显示特定时间段的用户规模以及增长率。 再将所得的规模数据与当前具有标准的规模进行比较，比如中国网名数量，移动端网名数量，来进行百分比对比。 市场前景用户分析用户画像 年龄和性别信息 地域分布 核心用户和主流用户核心用户：指对产品的发展做出贡献的忠实用户。 用户占比比较小，却很重要。 主流用户：是指消费产品内容和功能的用户。 用户占比非常大。 对每个竞品进行核心用户和主流用户分析。 功能分析基本功能核心功能对比部分功能测试关键功能流程把每个竞品的功能页面图截取出来放在一起–&gt;再用一个流程图去集中表示过程–&gt;然后对每个竞品的关键功能流程进行分析，一次列项表示出来–&gt;最后进行流程总述 提示：一般必须关注登录注册流程。 创新功能列出每个竞品的创新功能，并加以分析评价。 交互视觉设计交互设计分析每个竞品在交互设计上都有什么突出表现。具体突出表现是什么，依次对竞品进行分析。 视觉设计对每个竞品进行分析。例如先对竞品A分析，在一个框架内，列出竞品A的主要页面设计截图。最后对每个竞品的整体风格、排版设计、icon设计、竞品主图、字体字号进行总结。 运营分析内容运营何为内容运营？大致为如下解释：采集与创造——（内容的生产者来完成，可能是用户，也可能是产品本身）呈现与管理——（主要是产品本身来完成）扩散与传导——（由用户和产品本身共同完成，比如分享）效果与评估——（由用户和产品本身共同完成，比如用户点赞评论反馈，产品本身对内容的审核等）对每个竞品进行内容运营分析比如对竞品A进行分析：在一个框架内列出三个区域，依次为：内容生产者产品本身内容消费者 用户运营何为用户运营？“用户运营”对于一个产品来说尤为重要，它的主要内容包括：拉新用户维护老用户活跃度建立用户流失预警机制对已流失的用户进行挽回促进用户付费 活动运营渠道运营 产品评价应用商店评价比如安卓平均评分、IOS平均评分，安卓总评论人数，IOS总评论人数，然后对其进行分析总结 去应用商店评论去收集好评，和差评的具体内容，去挖掘产品问题然后去改进。 百度、微博、知乎评价分别进行评价汇总 最后关于竞品分析的几点个人思考 1：通过对网上各路大牛竞品分析的相关文章，案例的研究，总结了自己的一套竞品分析流程。2：分析尽可能通俗易懂，不搞什么专业术语，好像逼格很高的样子，其实空洞乏味。3：这个竞品分析模版主要是研究产品本身，大篇幅分析功能设计，然后按照产品运营的思路进行了运营分析。4：真正项目的竞品分析，是有目的，有针对性的，不同的阶段竞品分析的意义也不同，所以不要盲目跟随别人的竞品分析模板。5：这套竞品分析中的数据来源于“百度指数”和“ASO100”，为什么没有选大家习惯用的“易观千帆”，“艾瑞数据”，”TalkingData”或者是“baiduMOTA”这些看起来可能专业的数据分析平台，对比了一下这些平台上的数据，大方向差不多，但是数据相差甚远，比如产品用户的性别属性，差30%的都有。反正吧，最终衡量选择了“百度指数”，虽然不能准确反映APP的具体数据，但是或许可以反映APP的真是情况。6：“竞品分析”是主观和客观的结合，所以你认为的可以是你认为的，你认为的不一定是你认为的，辩证看待。7：竞品分析要注重分析方法。]]></content>
      <categories>
        <category>产品经理</category>
      </categories>
      <tags>
        <tag>竞品分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[必须知道的产品经理专业术语]]></title>
    <url>%2F2016%2F10%2F03%2F%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[MRD：Market Requirements Document (市场需求文档) PRD：Product Requirements Document (产品需求文档) 注意：MRD和PRD互为因果，有了输入MRD才能有输出PRD KPI：Key Performance Indicator(关键绩效指标) PV：page view(页面浏览量) UV：unique visitor(独立IP) FSD：Functional Specifications Document (功能详细说明文档) C2C：Consumer to Consumer(顾客对顾客) B2B：Business to Business(商家对商家) O2O：Online to Offline(线上线下电子商务) P2P：person to person B2C：Business to Consumer(商家对个人) UCD：User Centered Design(以用户为中心的设计) SNS：Social Networking Services(社会性网络服务) IM：Instant Messaging(即时通信) JD：Job Descriptions(职位描述) LBS：Location Based Service(基于位置的服务) RSS：Really Simple Syndication(简易信息聚合) SDK：Software Development Kit(软件开发工具包) DAU：Daily Active User(日活跃用户量) OTA：Online Travel Agent(在线旅行社) UX：User Experience Design(用户体验) UI：User Interface(用户界面) UGC：User Generated Content(用户生产内容) CLI：Command-line Interface(命令行界面) GUI：Graphical User Interface(图形用户界面) NUI：Natural User Interface(自然用户界面) GM：General Manager (总经理) VP：Vice President (副总裁) AVP：Assistant Vice President (副总裁助理) HRD：Human Resource Director (人力资源总监) OD：Operations Director (运营总监) MD：Marketing Director (市场总监) OM：Operations Manager (运作经理) PM：Production Manager(生产经理)、Product Manager(产品经理)、Project Manager(项目经理) BM：Branch Manager(部门经理) DM：District Manager(区域经理) URL：Uniform Resoure Locator(统一资源定位器) UED：User Experience Design(用户体验设计师) GMV：Gross Merchandise Volume(商品交易总量) SEO：Search Engine Optimization(搜索引擎优化) SKU：Stock Keeping Unit(库存量单位) SPU：Standard Product Unit (标准化产品单元) ROI：Return On Investment(投资回报率) C2C：Copy to China(借鉴国外成功产品模式) ERP：Enterprise Resource Planning(企业资源计划) POA：Primary Optical Area(第一视觉落点区) MVPMinimum Viable Product，最小可行产品，即用最低的成本实现一个尽可能展示核心概念的产品，产品团队可以通过它收集到尽可能多的用户反馈和数据，从而评估这个产品能带来的效益。 进入壁垒 进入壁垒指的是进入某一市场的难度，这一高度取决于自身的技术、成本、对特定资源的占有情况，以及对手的发展程度。如果进入壁垒过高，比如想要做一个超越Google的搜索引擎，这件事在地球上没几个人能做到;如果进入壁垒过低，人人都可以做，那就意味着你的蓝海时段会很短，可能难以获得足够支撑长期发展的用户规模。 商业价值 商业模式指的是一款产品如何创造价值。侠义上来说，就是如何赚钱，广义上来讲，除了经济上的价值，还有社会价值和其他形式的价值。例如不少开源组织，尽管他们自身并不盈利，仅依靠一些基金会维持自身的运作，但其创造了大量的社会价值。虽然这其中并没有钱的味道，但这依然叫做“商业”价值。 PDD PDD(Product Design Document)产品设计文档，是伴随产品整个生命周期的连接概念与执行的重要工具，它帮助产品团队与研发团队和高层领导达成共识，进而明确研发计划并指导研发过程。 PDD主要包含三类图纸：网站结构图(Website Architecture Map)、网站蓝图(Wireframe或者Mockups)和网页描述表(Page Description Diagram)。 网站结构图通常会以思维导图的形式展现，用于描述整个网站的结构，确定网站的模块划分及网页个数。有的地方也称之为“站点地图”。在绘制网站结构图时，要注意MECE原则(Mutually Exclusive Collectively Exhaustive)，中文含义是“互相独立，完全穷尽”，即要求分类清晰，降低理解门槛，不重复，不缺漏。可以使用MindManager、Omnigraffle、XMind等来做。 网站蓝图，还有一个名字叫“交互设计图”。描述了一个网页中所需要包含的基础元素机器在这个页面中的布局，它会由图形界面设计师最终完善成美观的网页设计图。通常会使用Axure、Visio、Fireworks、Photoshop、Balsamiq Mockups等工具完成。小公司中通常由产品经理单独负责，大公司里会有专门的交互设计师来合作完成。 网页描述表是这三类图中最符合“文档”的概念的。因为它完全可以就是一份word文档。它包含了一个网页中所需展示的元素及其背后的逻辑，并不包含这些元素在页面中的布局(这在网站蓝图中有)。例如：域名、标题、Logo、模块名称及其描述、版权信息等。 注意：PDD的目标用户，首先是产品团队，需要团队内部达成共识;然后是研发团队，用于确认可行性和研发成本;接下来会和研发部门给出的评估意见一起交给高层领导，确认项目周期，拍板资源;项目启动后，PDD回到研发团队指导具体的研发工作，同时进入测试团队，帮助制定测试计划。有时候，外部合作伙伴也会需要查看PDD，以便完成一些合作项目。这其中最重要的目标用户就是研发团队，因为他们是实现所有设计的核心力量，至于领导那边，还是用ppt和keynote去搞定最有效。 提一下墨菲定律 墨菲定律原本的意思是说：事情如果有变坏的可能，不管这种可能性有多小，它总会发生。简单的说就是“越怕出事，越会出事”。 放到互联网行业通常就是这样： 凡是输入框，都会遭遇灌水、SPAM、脚本注入。 凡是积分，都会被刷。 凡是推到网站首页的内容，都会出现色情、政治。 凡是用户间沟通的渠道，都会被广告机器人利用。 而对于项目管理而言，又可能是这样： 一项工作如果只有一个人负责，这个人肯定会休假或者离职。 认为没有技术难点的地方，都会成为技术难点或性能瓶颈。]]></content>
      <categories>
        <category>产品经理</category>
      </categories>
      <tags>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让创业团队拧成一股绳的不败法则]]></title>
    <url>%2F2016%2F09%2F15%2F%E8%AE%A9%E5%88%9B%E4%B8%9A%E5%9B%A2%E9%98%9F%E6%8B%A7%E6%88%90%E4%B8%80%E8%82%A1%E7%BB%B3%E7%9A%84%E4%B8%8D%E8%B4%A5%E6%B3%95%E5%88%99%2F</url>
    <content type="text"><![CDATA[序：千人同心,则得千人之力;万人异心,则无一人之用。 团队生存法则记住：没有人能能够脱离团队的力量而独自生存，不论你有多强。 追求公平，不如崇尚公正。 不管什么事，都要做好最坏的打算。 什么样的人在团队中有较好的前景呢？经验丰富者；最年轻和富有活力者；最机智而年富力强者，这是自然的选择。 在一个团队中，喜欢说谎者必须离开。 懒惰的强者必须离开。 交流和沟通能力存在巨大问题的也得离开。 喜欢在团队中尔虞我诈的人必须离开，阴谋的爱好者，最后会死于阴谋。 必须谦虚而尊重同事，否则将被淘汰。 在激烈的团队竞争中，个人的生存只有两条路，支持和反对，如果你想走第三条路，一定会失败。 利用一切办法，让别人了解你，理解你。 做一个诚实的人，这一点永远不要改变。 团队管理法则必须有明确的分工，这样团队中的成员才能知道自己该做什么，需要达到什么目标。 团队获得的利益一定要共享，必须确保每一个团队成员都能获得公正的利益。公正的分配方式是最有利的武器。 不管你有多么成功，切记，将功劳与荣耀归于团队的伙伴。 知人善用。 守承诺，讲信用，答应的事情一定要做到。 保持自信和乐观。 必须具备很高的交际能力，他可以与任何人就任何话题沟通，并总能说服对方，或者大度的被说服。 对待下属要有人情味。 团队团结奥秘把同事当队友，而非你的对手。 心胸大点，不要去排挤同事。 你成就了团队，团队也会成就你。 团队个人法则做决定时犹豫不决和在工作中依赖别人的人，难以晋升。 永远不要埋怨。]]></content>
      <categories>
        <category>释放团队力量</category>
      </categories>
      <tags>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产品经理的职业修养]]></title>
    <url>%2F2016%2F09%2F15%2F%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%9A%84%E8%81%8C%E4%B8%9A%E4%BF%AE%E5%85%BB%2F</url>
    <content type="text"><![CDATA[序：学道客，修养莫迟迟，光景斯须如梦里。 8句话诚实。 有所长有所短。 对产品有信心并且做好了长期吃苦的思想准备。 能够在行进中不断开火，而不是纸上谈兵。 愿意倾听用户的意见和其他人善意的建议。 不推卸责任。 不会认为理论上可行就等于彻底搞定。 不会去浪费时间重新发明轮子。]]></content>
      <categories>
        <category>产品经理</category>
      </categories>
      <tags>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git知识总结]]></title>
    <url>%2F2016%2F08%2F10%2Fgit%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[遇到的所有问题：1：warning: LF will be replaced by CRLF in XXXXXXXXXXXXXX.解决 git config core.autocrlf false 2：github push 提交代码时停止在writing objects怎么办？git config –global http.postBuffer 524288000 3：新建仓库初始化时，不要点击初始化按钮，否则github就自动建立一个git仓库，并且生成一个版本库所以这样的话，那你用git push origin master就会说被拒绝这种情况要先git pull origin master再git push origin master 一开始怎么绑定github账号设置全局用户名和email，作为每次提交的记录git config –global user.name “name”git config –global user.email “mail.com” 添加一个仓库git remote add origin git@….gitgit push -u origin master 当提示权限不够时，添加ssh公钥在用户的.ssh目录下找id_rsa.pub等文件，没有的话去生成ssh-keygen -t rsa -C “youremail@example.com” 设置pull的默认地址git branch –set-upstream-to=origin/master 设置push的默认地址git remote add origin git@….git 配置别名git config –global alias.xx ‘’ 临时保存工作区git stashgit stash pop 回滚git reset —hard 版本号 强行回滚远程服务器git push -f]]></content>
      <categories>
        <category>工具能力</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的团队需要一个会讲故事的人]]></title>
    <url>%2F2016%2F06%2F10%2F%E7%94%A8%E6%95%85%E4%BA%8B%E6%80%9D%E7%BB%B4%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[每看完一本书都有一种技能升级的体会，于是迫不及待的记录下人生中那种获得升华的体会。 何为故事互动能够让人找到发自内心的、来源于实践的意义，让讲故事的人和听故事的人都得到满足，这才是故事。那些下意识就把故事定义为一个有开头、过程和结尾的人一定还没有理解到故事的本质。 重温回忆，留心自己所讲的故事可以通过改变你的故事来改变现实感受。 好的故事配方一般好故事由三部分组成，旧规矩、中间的波折，新规矩。 一点建议试图通过逻辑来控制人们的看法会让对方戒备心增强，会驱使对方离你越来越远。让故事变得更加有人情味。 团队团队真正的信任来源于诚实。 慈善和团结慈善是纵向的，来源于由上到下的评判。团结是水平的，有利于平等交流。一个团队要多团结，不要多慈善。 学会从不同视角读你的故事花时间从不同视角审视重要的故事，就能尽可能避免挫伤他人的感情，避免人们浪费时间去生气。 领导如何讲故事不要把主人公的自我意识加到故事中，那样的话对听众来说，这故事只是属于你的故事，毫无感染力。要控制自我意识。 “我是谁”的故事讲故事之前要弄明白这些问题：你是谁？你的特别之处是什么？为何你可以影响他人？人人都有天赋，你的天赋是哪些？你是富有同情，是值得信赖，是诚实，还是圆滑老练？你的什么本领让你有了影响他人的权利？ 学会倾听无论对方和你的观点多么不可调和，也要深入理解对方的观点，暂时放下自己的观点，这样的倾听才能让你赢得讲诉自己故事的机会。津津有味地倾听，抱着可能会学到重要知识的期待去倾听。 领导如何讲故事不要把主人公的自我意识加到故事中，那样的话对听众来说，这故事只是属于你的故事，毫无感染力。要控制自我意识。]]></content>
      <categories>
        <category>能力提升</category>
      </categories>
      <tags>
        <tag>团队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产品经理的最佳实践]]></title>
    <url>%2F2016%2F05%2F11%2F%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[产品经理的职责 许多产品经理将大把的时间浪费在与产品无关的工作上，比如，营销管理和项目管理，这些都不是产品经理应该干的活 用户体验 对于大多数软件产品来说，用户体验就是产品的生命。产品经理应该与交互设计师、开发人员密切合作，设计良好的用户体验，打造实用价值的产品。 机会评估 用方便快捷的机会评估方法取代过时的市场需求文档。动手设计产品前，先明确产品需要解决什么问题，为谁解决问题，以及评估产品的标准。 特约用户 打造优秀的产品没有任何捷径，只能请用户反复试用产品，不断改进。 产品原则 产品管理工作的主要内容是制定决策。明确的产品原则则可以帮助产品经理和产品团队树立清晰的价值标准，做出果断的依据。 探索【定义】产品 产品经理的主要职责是探索（定义）有价值的、可用的、可行的产品。除非产品经理确定这三点，否则同事的努力都将付之东流。 使用原型 使用高保真原型是探索产品的关键步骤。原因如下：第一，迫使产品经理深入定义解决方案；第二，可以让真实的用户参与测试、验证产品创意；第三，可以直观地向团队展示产品的设计和思路。 用户参与原型测试 有了产品原型，产品经理可以方便地请用户验证产品创意。原型测试是所有产品经理和产品设计师都必须掌握的工作技能。获取有效的用户反馈是产品经理最重要的工作。 根据数据改进产品 成功的产品经理懂得利用数据来改进现有产品。改进产品不是根据客户要求一味增加新功能，而是根据产品的实际应用情况，不断地提升产品的各项指标，逐步完善产品。]]></content>
      <categories>
        <category>产品经理</category>
      </categories>
      <tags>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产品经理的反省清单]]></title>
    <url>%2F2016%2F05%2F10%2F%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%9A%84%E5%8F%8D%E7%9C%81%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[不为失败找借口，只为成功找方法 产品能吸引目标消费者的关注吗？ 产品的设计是否人性化，易于操作？ 产品能在竞争中取胜吗？即使是面对未来风云变化的市场，依旧有取胜的把握吗？ 我了解目标用户吗？产品（不是理想的产品，而是实际开发出来的产品）是否能得到他们的认可？ 产品是否有别与市面上的其他产品？我能在两分钟内想公司高管清除地阐明这些差别吗？能在一分钟内向客户解释清除吗？能在半分钟内向经验丰富的行业分析师解释清除吗？ 产品能正常运行吗？ 产品是否完整？用户对产品的印象如何？销售业绩如何？销售任务能否顺利完成？ 产品的特色 是否与目标用户的需求一致？产品特色是否鲜明？ 产品值钱吗？值多少钱？为什么值这么多钱？用户会选择更便宜的产品吗？ 我了解其他团队成员对产品的看法吗？他们觉得产品好在哪里？他们的看法是否与我的观点一致]]></content>
      <categories>
        <category>产品经理</category>
      </categories>
      <tags>
        <tag>产品经理</tag>
      </tags>
  </entry>
</search>